{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/core/base/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './ERC721Time.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\n * NOTE: Modified from Openzeppelin to inherit from a modified ERC721 contract.\n */\nabstract contract ERC721Enumerable is ERC721Time, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721Time)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(index < ERC721Time.balanceOf(owner), 'ERC721Enumerable: owner index out of bounds');\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(\n            index < ERC721Enumerable.totalSupply(),\n            'ERC721Enumerable: global index out of bounds'\n        );\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Time.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Time.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/core/base/ERC721Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './IERC721Time.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\n * Modifications:\n * 1. Refactored _operatorApprovals setter into an internal function to allow meta-transactions.\n * 2. Constructor replaced with an initializer.\n * 3. Mint timestamp is now stored in a TokenData struct alongside the owner address.\n */\nabstract contract ERC721Time is Context, ERC165, IERC721Time, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to token Data (owner address and mint timestamp uint96), this\n    // replaces the original mapping(uint256 => address) private _owners;\n    mapping(uint256 => IERC721Time.TokenData) private _tokenData;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the ERC721 name and symbol.\n     *\n     * @param name The name to set.\n     * @param symbol The symbol to set.\n     */\n    function __ERC721_Init(string calldata name, string calldata symbol) internal {\n        _name = name;\n        _symbol = symbol;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), 'ERC721: balance query for the zero address');\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _tokenData[tokenId].owner;\n        require(owner != address(0), 'ERC721: owner query for nonexistent token');\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Time-mintTimestampOf}\n     */\n    function mintTimestampOf(uint256 tokenId) public view virtual override returns (uint256) {\n        uint96 mintTimestamp = _tokenData[tokenId].mintTimestamp;\n        require(mintTimestamp != 0, 'ERC721: mint timestamp query for nonexistent token');\n        return mintTimestamp;\n    }\n\n    /**\n     * @dev See {IERC721Time-mintTimestampOf}\n     */\n    function tokenDataOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (IERC721Time.TokenData memory)\n    {\n        require(_exists(tokenId), 'ERC721: token data query for nonexistent token');\n        return _tokenData[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Time-exists}\n     */\n    function exists(uint256 tokenId) public view virtual override returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Time.ownerOf(tokenId);\n        require(to != owner, 'ERC721: approval to current owner');\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            'ERC721: approve caller is not owner nor approved for all'\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), 'ERC721: approve to caller');\n\n        _setOperatorApproval(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721: transfer caller is not owner nor approved'\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721: transfer caller is not owner nor approved'\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenData[tokenId].owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\n        address owner = ERC721Time.ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), 'ERC721: mint to the zero address');\n        require(!_exists(tokenId), 'ERC721: token already minted');\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _tokenData[tokenId].owner = to;\n        _tokenData[tokenId].mintTimestamp = uint96(block.timestamp);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Time.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _tokenData[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Time.ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\n        require(to != address(0), 'ERC721: transfer to the zero address');\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _tokenData[tokenId].owner = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Time.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Refactored from the original OZ ERC721 implementation: approve or revoke approval from\n     * `operator` to operate on all tokens owned by `owner`.\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setOperatorApproval(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "contracts/core/base/IERC721Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title IERC721Time\n * @author Lens Protocol\n *\n * @notice This is an expansion of the IERC721 interface that includes a struct for token data,\n * which contains the token owner and the mint timestamp as well as associated getters.\n */\ninterface IERC721Time is IERC721 {\n    /**\n     * @notice Contains the owner address and the mint timestamp for every NFT.\n     *\n     * Note: Instead of the owner address in the _tokenOwners private mapping, we now store it in the\n     * _tokenData mapping, alongside the unchanging mintTimestamp.\n     *\n     * @param owner The token owner.\n     * @param mintTimestamp The mint timestamp.\n     */\n    struct TokenData {\n        address owner;\n        uint96 mintTimestamp;\n    }\n\n    /**\n     * @notice Returns the mint timestamp associated with a given NFT, stored only once upon initial mint.\n     *\n     * @param tokenId The token ID of the NFT to query the mint timestamp for.\n     *\n     * @return uint256 mint timestamp, this is stored as a uint96 but returned as a uint256 to reduce unnecessary\n     * padding.\n     */\n    function mintTimestampOf(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the token data associated with a given NFT. This allows fetching the token owner and\n     * mint timestamp in a single call.\n     *\n     * @param tokenId The token ID of the NFT to query the token data for.\n     *\n     * @return TokenData token data struct containing both the owner address and the mint timestamp.\n     */\n    function tokenDataOf(uint256 tokenId) external view returns (TokenData memory);\n\n    /**\n     * @notice Returns whether a token with the given token ID exists.\n     *\n     * @param tokenId The token ID of the NFT to check existence for.\n     *\n     * @return bool True if the token exists.\n     */\n    function exists(uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/core/base/LensMultiState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Events} from '../../libraries/Events.sol';\nimport {DataTypes} from '../../libraries/DataTypes.sol';\nimport {Errors} from '../../libraries/Errors.sol';\n\n/**\n * @title LensMultiState\n *\n * @notice This is an abstract contract that implements internal LensHub state setting and validation.\n *\n * whenNotPaused: Either publishingPaused or Unpaused.\n * whenPublishingEnabled: When Unpaused only.\n */\nabstract contract LensMultiState {\n    DataTypes.ProtocolState private _state;\n\n    modifier whenNotPaused() {\n        _validateNotPaused();\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        _validatePublishingEnabled();\n        _;\n    }\n\n    /**\n     * @notice Returns the current protocol state.\n     *\n     * @return ProtocolState The Protocol state, an enum, where:\n     *      0: Unpaused\n     *      1: PublishingPaused\n     *      2: Paused\n     */\n    function getState() external view returns (DataTypes.ProtocolState) {\n        return _state;\n    }\n\n    function _setState(DataTypes.ProtocolState newState) internal {\n        DataTypes.ProtocolState prevState = _state;\n        _state = newState;\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n    }\n\n    function _validatePublishingEnabled() internal view {\n        if (_state != DataTypes.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n    }\n\n    function _validateNotPaused() internal view {\n        if (_state == DataTypes.ProtocolState.Paused) revert Errors.Paused();\n    }\n}\n"
    },
    "contracts/core/base/LensNFTBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensNFTBase} from '../../interfaces/ILensNFTBase.sol';\nimport {Errors} from '../../libraries/Errors.sol';\nimport {DataTypes} from '../../libraries/DataTypes.sol';\nimport {Events} from '../../libraries/Events.sol';\nimport {ERC721Time} from './ERC721Time.sol';\nimport {ERC721Enumerable} from './ERC721Enumerable.sol';\n\n/**\n * @title LensNFTBase\n * @author Lens Protocol\n *\n * @notice This is an abstract base contract to be inherited by other Lens Protocol NFTs, it includes\n * the slightly modified ERC721Enumerable, which itself inherits from the ERC721Time-- which adds an\n * internal operator approval setter, stores the mint timestamp for each token, and replaces the\n * constructor with an initializer.\n */\nabstract contract LensNFTBase is ERC721Enumerable, ILensNFTBase {\n    bytes32 internal constant EIP712_REVISION_HASH = keccak256('1');\n    bytes32 internal constant PERMIT_TYPEHASH =\n        keccak256('Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)');\n    bytes32 internal constant PERMIT_FOR_ALL_TYPEHASH =\n        keccak256(\n            'PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant BURN_WITH_SIG_TYPEHASH =\n        keccak256('BurnWithSig(uint256 tokenId,uint256 nonce,uint256 deadline)');\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n        );\n\n    mapping(address => uint256) public sigNonces;\n\n    /**\n     * @notice Initializer sets the name, symbol and the cached domain separator.\n     *\n     * NOTE: Inheritor contracts *must* call this function to initialize the name & symbol in the\n     * inherited ERC721 contract.\n     *\n     * @param name The name to set in the ERC721 contract.\n     * @param symbol The symbol to set in the ERC721 contract.\n     */\n    function _initialize(string calldata name, string calldata symbol) internal {\n        ERC721Time.__ERC721_Init(name, symbol);\n\n        emit Events.BaseInitialized(name, symbol, block.timestamp);\n    }\n\n    /// @inheritdoc ILensNFTBase\n    function permit(\n        address spender,\n        uint256 tokenId,\n        DataTypes.EIP712Signature calldata sig\n    ) external override {\n        if (spender == address(0)) revert Errors.ZeroSpender();\n        address owner = ownerOf(tokenId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            spender,\n                            tokenId,\n                            sigNonces[owner]++,\n                            sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                sig\n            );\n        }\n        _approve(spender, tokenId);\n    }\n\n    /// @inheritdoc ILensNFTBase\n    function permitForAll(\n        address owner,\n        address operator,\n        bool approved,\n        DataTypes.EIP712Signature calldata sig\n    ) external override {\n        if (operator == address(0)) revert Errors.ZeroSpender();\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            PERMIT_FOR_ALL_TYPEHASH,\n                            owner,\n                            operator,\n                            approved,\n                            sigNonces[owner]++,\n                            sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                sig\n            );\n        }\n        _setOperatorApproval(owner, operator, approved);\n    }\n\n    /// @inheritdoc ILensNFTBase\n    function getDomainSeparator() external view override returns (bytes32) {\n        return _calculateDomainSeparator();\n    }\n\n    /// @inheritdoc ILensNFTBase\n    function burn(uint256 tokenId) public virtual override {\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) revert Errors.NotOwnerOrApproved();\n        _burn(tokenId);\n    }\n\n    /// @inheritdoc ILensNFTBase\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        virtual\n        override\n    {\n        address owner = ownerOf(tokenId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            BURN_WITH_SIG_TYPEHASH,\n                            tokenId,\n                            sigNonces[owner]++,\n                            sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                sig\n            );\n        }\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\n     */\n    function _validateRecoveredAddress(\n        bytes32 digest,\n        address expectedAddress,\n        DataTypes.EIP712Signature calldata sig\n    ) internal view {\n        if (sig.deadline < block.timestamp) revert Errors.SignatureExpired();\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n        if (recoveredAddress == address(0) || recoveredAddress != expectedAddress)\n            revert Errors.SignatureInvalid();\n    }\n\n    /**\n     * @dev Calculates EIP712 DOMAIN_SEPARATOR based on the current contract and chain ID.\n     */\n    function _calculateDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(bytes(name())),\n                    EIP712_REVISION_HASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\n     *\n     * @param hashedMessage The message hash from which the digest should be calculated.\n     *\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\n     */\n    function _calculateDigest(bytes32 hashedMessage) internal view returns (bytes32) {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked('\\x19\\x01', _calculateDomainSeparator(), hashedMessage)\n            );\n        }\n        return digest;\n    }\n}\n"
    },
    "contracts/core/CollectNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {ERC721Enumerable} from './base/ERC721Enumerable.sol';\n\n/**\n * @title CollectNFT\n * @author Lens Protocol\n *\n * @notice This is the NFT contract that is minted upon collecting a given publication. It is cloned upon\n * the first collect for a given publication, and the token URI points to the original publication's contentURI.\n */\ncontract CollectNFT is LensNFTBase, ICollectNFT {\n    address public immutable HUB;\n\n    uint256 internal _profileId;\n    uint256 internal _pubId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    uint256 internal _royaltyBasisPoints;\n\n    // bytes4(keccak256('royaltyInfo(uint256,uint256)')) == 0x2a55205a\n    bytes4 internal constant INTERFACE_ID_ERC2981 = 0x2a55205a;\n    uint16 internal constant BASIS_POINTS = 10000;\n\n    // We create the CollectNFT with the pre-computed HUB address before deploying the hub proxy in order\n    // to initialize the hub proxy at construction.\n    constructor(address hub) {\n        if (hub == address(0)) revert Errors.InitParamsInvalid();\n        HUB = hub;\n        _initialized = true;\n    }\n\n    /// @inheritdoc ICollectNFT\n    function initialize(\n        uint256 profileId,\n        uint256 pubId,\n        string calldata name,\n        string calldata symbol\n    ) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _royaltyBasisPoints = 1000; // 10% of royalties\n        _profileId = profileId;\n        _pubId = pubId;\n        super._initialize(name, symbol);\n        emit Events.CollectNFTInitialized(profileId, pubId, block.timestamp);\n    }\n\n    /// @inheritdoc ICollectNFT\n    function mint(address to) external override returns (uint256) {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        unchecked {\n            uint256 tokenId = ++_tokenIdCounter;\n            _mint(to, tokenId);\n            return tokenId;\n        }\n    }\n\n    /// @inheritdoc ICollectNFT\n    function getSourcePublicationPointer() external view override returns (uint256, uint256) {\n        return (_profileId, _pubId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getContentURI(_profileId, _pubId);\n    }\n\n    /**\n     * @notice Changes the royalty percentage for secondary sales. Can only be called publication's\n     *         profile owner.\n     *\n     * @param royaltyBasisPoints The royalty percentage meassured in basis points. Each basis point\n     *                           represents 0.01%.\n     */\n    function setRoyalty(uint256 royaltyBasisPoints) external {\n        if (IERC721(HUB).ownerOf(_profileId) == msg.sender) {\n            if (royaltyBasisPoints > BASIS_POINTS) {\n                revert Errors.InvalidParameter();\n            } else {\n                _royaltyBasisPoints = royaltyBasisPoints;\n            }\n        } else {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    /**\n     * @notice Called with the sale price to determine how much royalty\n     *         is owed and to whom.\n     *\n     * @param tokenId The token ID of the NFT queried for royalty information.\n     * @param salePrice The sale price of the NFT specified.\n     * @return A tuple with the address who should receive the royalties and the royalty\n     * payment amount for the given sale price.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address, uint256)\n    {\n        return (IERC721(HUB).ownerOf(_profileId), (salePrice * _royaltyBasisPoints) / BASIS_POINTS);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Enumerable)\n        returns (bool)\n    {\n        return interfaceId == INTERFACE_ID_ERC2981 || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Upon transfers, we emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitCollectNFTTransferEvent(_profileId, _pubId, tokenId, from, to);\n    }\n}\n"
    },
    "contracts/core/FollowNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Constants} from '../libraries/Constants.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\n\n/**\n * @title FollowNFT\n * @author Lens Protocol\n *\n * @notice This contract is the NFT that is minted upon following a given profile. It is cloned upon first follow for a\n * given profile, and includes built-in governance power and delegation mechanisms.\n *\n * NOTE: This contract assumes total NFT supply for this follow NFT will never exceed 2^128 - 1\n */\ncontract FollowNFT is LensNFTBase, IFollowNFT {\n    struct Snapshot {\n        uint128 blockNumber;\n        uint128 value;\n    }\n\n    address public immutable HUB;\n\n    bytes32 internal constant DELEGATE_BY_SIG_TYPEHASH =\n        keccak256(\n            'DelegateBySig(address delegator,address delegatee,uint256 nonce,uint256 deadline)'\n        );\n\n    mapping(address => mapping(uint256 => Snapshot)) internal _snapshots;\n    mapping(address => address) internal _delegates;\n    mapping(address => uint256) internal _snapshotCount;\n    mapping(uint256 => Snapshot) internal _delSupplySnapshots;\n    uint256 internal _delSupplySnapshotCount;\n    uint256 internal _profileId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    // We create the FollowNFT with the pre-computed HUB address before deploying the hub.\n    constructor(address hub) {\n        if (hub == address(0)) revert Errors.InitParamsInvalid();\n        HUB = hub;\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _profileId = profileId;\n        emit Events.FollowNFTInitialized(profileId, block.timestamp);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function mint(address to) external override returns (uint256) {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        unchecked {\n            uint256 tokenId = ++_tokenIdCounter;\n            _mint(to, tokenId);\n            return tokenId;\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegate(address delegatee) external override {\n        _delegate(msg.sender, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegateBySig(\n        address delegator,\n        address delegatee,\n        DataTypes.EIP712Signature calldata sig\n    ) external override {\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            DELEGATE_BY_SIG_TYPEHASH,\n                            delegator,\n                            delegatee,\n                            sigNonces[delegator]++,\n                            sig.deadline\n                        )\n                    )\n                ),\n                delegator,\n                sig\n            );\n        }\n        _delegate(delegator, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getPowerByBlockNumber(address user, uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n        uint256 snapshotCount = _snapshotCount[user];\n        if (snapshotCount == 0) return 0; // Returning zero since this means the user never delegated and has no power\n        return _getSnapshotValueByBlockNumber(_snapshots[user], blockNumber, snapshotCount);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getDelegatedSupplyByBlockNumber(uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n        uint256 snapshotCount = _delSupplySnapshotCount;\n        if (snapshotCount == 0) return 0; // Returning zero since this means a delegation has never occurred\n        return _getSnapshotValueByBlockNumber(_delSupplySnapshots, blockNumber, snapshotCount);\n    }\n\n    function name() public view override returns (string memory) {\n        string memory handle = ILensHub(HUB).getHandle(_profileId);\n        return string(abi.encodePacked(handle, Constants.FOLLOW_NFT_NAME_SUFFIX));\n    }\n\n    function symbol() public view override returns (string memory) {\n        string memory handle = ILensHub(HUB).getHandle(_profileId);\n        bytes4 firstBytes = bytes4(bytes(handle));\n        return string(abi.encodePacked(firstBytes, Constants.FOLLOW_NFT_SYMBOL_SUFFIX));\n    }\n\n    function _getSnapshotValueByBlockNumber(\n        mapping(uint256 => Snapshot) storage _shots,\n        uint256 blockNumber,\n        uint256 snapshotCount\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 lower = 0;\n            uint256 upper = snapshotCount - 1;\n\n            // First check most recent snapshot\n            if (_shots[upper].blockNumber <= blockNumber) return _shots[upper].value;\n\n            // Next check implicit zero balance\n            if (_shots[lower].blockNumber > blockNumber) return 0;\n\n            while (upper > lower) {\n                uint256 center = upper - (upper - lower) / 2;\n                Snapshot memory snapshot = _shots[center];\n                if (snapshot.blockNumber == blockNumber) {\n                    return snapshot.value;\n                } else if (snapshot.blockNumber < blockNumber) {\n                    lower = center;\n                } else {\n                    upper = center - 1;\n                }\n            }\n            return _shots[lower].value;\n        }\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getFollowNFTURI(_profileId);\n    }\n\n    /**\n     * @dev Upon transfers, we move the appropriate delegations, and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        address fromDelegatee = _delegates[from];\n        address toDelegatee = _delegates[to];\n        address followModule = ILensHub(HUB).getFollowModule(_profileId);\n\n        _moveDelegate(fromDelegatee, toDelegatee, 1);\n\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitFollowNFTTransferEvent(_profileId, tokenId, from, to);\n        if (followModule != address(0)) {\n            IFollowModule(followModule).followModuleTransferHook(_profileId, from, to, tokenId);\n        }\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        uint256 delegatorBalance = balanceOf(delegator);\n        address previousDelegate = _delegates[delegator];\n        _delegates[delegator] = delegatee;\n        _moveDelegate(previousDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegate(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        unchecked {\n            bool fromZero = from == address(0);\n            if (!fromZero) {\n                uint256 fromSnapshotCount = _snapshotCount[from];\n\n                // Underflow is impossible since, if from != address(0), then a delegation must have occurred (at least 1 snapshot)\n                uint256 previous = _snapshots[from][fromSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous - amount);\n\n                _writeSnapshot(from, newValue, fromSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(from, newValue, block.timestamp);\n            }\n\n            if (to != address(0)) {\n                // if from == address(0) then this is an initial delegation (add amount to supply)\n                if (fromZero) {\n                    // It is expected behavior that the `previousDelSupply` underflows upon the first delegation,\n                    // returning the expected value of zero\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply + amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n\n                // It is expected behavior that `previous` underflows upon the first delegation to an address,\n                // returning the expected value of zero\n                uint256 toSnapshotCount = _snapshotCount[to];\n                uint128 previous = _snapshots[to][toSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous + amount);\n                _writeSnapshot(to, newValue, toSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(to, newValue, block.timestamp);\n            } else {\n                // If from != address(0) then this is removing a delegation, otherwise we're dealing with a\n                // non-delegated burn of tokens and don't need to take any action\n                if (!fromZero) {\n                    // Upon removing delegation (from != address(0) && to == address(0)), supply calculations cannot\n                    // underflow because if from != address(0), then a delegation must have previously occurred, so\n                    // the snapshot count must be >= 1 and the previous delegated supply must be >= amount\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply - amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n            }\n        }\n    }\n\n    function _writeSnapshot(\n        address owner,\n        uint128 newValue,\n        uint256 ownerSnapshotCount\n    ) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n            mapping(uint256 => Snapshot) storage ownerSnapshots = _snapshots[owner];\n\n            // Doing multiple operations in the same block\n            if (\n                ownerSnapshotCount != 0 &&\n                ownerSnapshots[ownerSnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                ownerSnapshots[ownerSnapshotCount - 1].value = newValue;\n            } else {\n                ownerSnapshots[ownerSnapshotCount] = Snapshot(currentBlock, newValue);\n                _snapshotCount[owner] = ownerSnapshotCount + 1;\n            }\n        }\n    }\n\n    function _writeSupplySnapshot(uint128 newValue, uint256 supplySnapshotCount) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n\n            // Doing multiple operations in the same block\n            if (\n                supplySnapshotCount != 0 &&\n                _delSupplySnapshots[supplySnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                _delSupplySnapshots[supplySnapshotCount - 1].value = newValue;\n            } else {\n                _delSupplySnapshots[supplySnapshotCount] = Snapshot(currentBlock, newValue);\n                _delSupplySnapshotCount = supplySnapshotCount + 1;\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/LensHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {Constants} from '../libraries/Constants.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {ProfileTokenURILogic} from '../libraries/ProfileTokenURILogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage, ILensHub {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        if (followNFTImpl == address(0)) revert Errors.InitParamsInvalid();\n        if (collectNFTImpl == address(0)) revert Errors.InitParamsInvalid();\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender == _emergencyAdmin) {\n            if (newState == DataTypes.ProtocolState.Unpaused)\n                revert Errors.EmergencyAdminCannotUnpause();\n            _validateNotPaused();\n        } else if (msg.sender != _governance) {\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        }\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(vars.to, profileId);\n            PublishingLogic.createProfile(\n                vars,\n                profileId,\n                _profileIdByHandleHash,\n                _profileById,\n                _followModuleWhitelisted\n            );\n            return profileId;\n        }\n    }\n\n    /// @inheritdoc ILensHub\n    function setDefaultProfile(uint256 profileId) external override whenNotPaused {\n        _setDefaultProfile(msg.sender, profileId);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDefaultProfileWithSig(DataTypes.SetDefaultProfileWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            SET_DEFAULT_PROFILE_WITH_SIG_TYPEHASH,\n                            vars.wallet,\n                            vars.profileId,\n                            sigNonces[vars.wallet]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                vars.wallet,\n                vars.sig\n            );\n            _setDefaultProfile(vars.wallet, vars.profileId);\n        }\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleInitData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleInitData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleInitData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n        returns (uint256)\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        return\n            _createPost(\n                vars.profileId,\n                vars.contentURI,\n                vars.collectModule,\n                vars.collectModuleInitData,\n                vars.referenceModule,\n                vars.referenceModuleInitData\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n        returns (uint256)\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleInitData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleInitData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        return\n            _createPost(\n                vars.profileId,\n                vars.contentURI,\n                vars.collectModule,\n                vars.collectModuleInitData,\n                vars.referenceModule,\n                vars.referenceModuleInitData\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n        returns (uint256)\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        return _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n        returns (uint256)\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            keccak256(vars.referenceModuleData),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleInitData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleInitData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        return\n            _createComment(\n                DataTypes.CommentData(\n                    vars.profileId,\n                    vars.contentURI,\n                    vars.profileIdPointed,\n                    vars.pubIdPointed,\n                    vars.referenceModuleData,\n                    vars.collectModule,\n                    vars.collectModuleInitData,\n                    vars.referenceModule,\n                    vars.referenceModuleInitData\n                )\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n        returns (uint256)\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        return _createMirror(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n        returns (uint256)\n    {\n        address owner = ownerOf(vars.profileId);\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            keccak256(vars.referenceModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleInitData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        return\n            _createMirror(\n                DataTypes.MirrorData(\n                    vars.profileId,\n                    vars.profileIdPointed,\n                    vars.pubIdPointed,\n                    vars.referenceModuleData,\n                    vars.referenceModule,\n                    vars.referenceModuleInitData\n                )\n            );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n        returns (uint256[] memory)\n    {\n        return\n            InteractionLogic.follow(\n                msg.sender,\n                profileIds,\n                datas,\n                _profileById,\n                _profileIdByHandleHash\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n        returns (uint256[] memory)\n    {\n        uint256 dataLength = vars.datas.length;\n        bytes32[] memory dataHashes = new bytes32[](dataLength);\n        for (uint256 i = 0; i < dataLength; ) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                vars.follower,\n                vars.sig\n            );\n        }\n        return\n            InteractionLogic.follow(\n                vars.follower,\n                vars.profileIds,\n                vars.datas,\n                _profileById,\n                _profileIdByHandleHash\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused returns (uint256) {\n        return\n            InteractionLogic.collect(\n                msg.sender,\n                profileId,\n                pubId,\n                data,\n                COLLECT_NFT_IMPL,\n                _pubByIdByProfile,\n                _profileById\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                vars.collector,\n                vars.sig\n            );\n        }\n        return\n            InteractionLogic.collect(\n                vars.collector,\n                vars.profileId,\n                vars.pubId,\n                vars.data,\n                COLLECT_NFT_IMPL,\n                _pubByIdByProfile,\n                _profileById\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function defaultProfile(address wallet) external view override returns (uint256) {\n        return _defaultProfileByAddress[wallet];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n            return DataTypes.PubType.Post;\n        } else {\n            return DataTypes.PubType.Comment;\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        address followNFT = _profileById[tokenId].followNFT;\n        return\n            ProfileTokenURILogic.getProfileTokenURI(\n                tokenId,\n                followNFT == address(0) ? 0 : IERC721Enumerable(followNFT).totalSupply(),\n                ownerOf(tokenId),\n                _profileById[tokenId].handle,\n                _profileById[tokenId].imageURI\n            );\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTImpl() external view override returns (address) {\n        return FOLLOW_NFT_IMPL;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFTImpl() external view override returns (address) {\n        return COLLECT_NFT_IMPL;\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal returns (uint256) {\n        unchecked {\n            uint256 pubId = ++_profileById[profileId].pubCount;\n            PublishingLogic.createPost(\n                profileId,\n                contentURI,\n                collectModule,\n                collectModuleData,\n                referenceModule,\n                referenceModuleData,\n                pubId,\n                _pubByIdByProfile,\n                _collectModuleWhitelisted,\n                _referenceModuleWhitelisted\n            );\n            return pubId;\n        }\n    }\n\n    /*\n     * If the profile ID is zero, this is the equivalent of \"unsetting\" a default profile.\n     * Note that the wallet address should either be the message sender or validated via a signature\n     * prior to this function call.\n     */\n    function _setDefaultProfile(address wallet, uint256 profileId) internal {\n        if (profileId > 0 && wallet != ownerOf(profileId)) revert Errors.NotProfileOwner();\n\n        _defaultProfileByAddress[wallet] = profileId;\n\n        emit Events.DefaultProfileSet(wallet, profileId, block.timestamp);\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal returns (uint256) {\n        unchecked {\n            uint256 pubId = ++_profileById[vars.profileId].pubCount;\n            PublishingLogic.createComment(\n                vars,\n                pubId,\n                _profileById,\n                _pubByIdByProfile,\n                _collectModuleWhitelisted,\n                _referenceModuleWhitelisted\n            );\n            return pubId;\n        }\n    }\n\n    function _createMirror(DataTypes.MirrorData memory vars) internal returns (uint256) {\n        unchecked {\n            uint256 pubId = ++_profileById[vars.profileId].pubCount;\n            PublishingLogic.createMirror(\n                vars,\n                pubId,\n                _pubByIdByProfile,\n                _referenceModuleWhitelisted\n            );\n            return pubId;\n        }\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string calldata imageURI) internal {\n        if (bytes(imageURI).length > Constants.MAX_PROFILE_IMAGE_URI_LENGTH)\n            revert Errors.ProfileImageURILengthInvalid();\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string calldata followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override whenNotPaused {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n\n        if (_defaultProfileByAddress[from] == tokenId) {\n            _defaultProfileByAddress[from] = 0;\n        }\n\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender == ownerOf(profileId) || msg.sender == _dispatcherByProfile[profileId]) {\n            return;\n        }\n        revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n"
    },
    "contracts/core/modules/collect/FeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly Whether only followers should be able to collect.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    bool followerOnly;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is FeeModuleBase, FollowValidationModuleBase, ICollectModule {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *      bool followerOnly: Whether only followers should be able to collect.\n     *\n     * @return bytes An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (\n            uint256 amount,\n            address currency,\n            address recipient,\n            uint16 referralFee,\n            bool followerOnly\n        ) = abi.decode(data, (uint256, address, address, uint16, bool));\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount == 0\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].followerOnly = followerOnly;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        if (_dataByPublicationByProfile[profileId][pubId].followerOnly)\n            _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return ProfilePublicationData The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n"
    },
    "contracts/core/modules/collect/FreeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\n\n/**\n * @title FreeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface.\n *\n * This module works by allowing all collects.\n */\ncontract FreeCollectModule is FollowValidationModuleBase, ICollectModule {\n    constructor(address hub) ModuleBase(hub) {}\n\n    mapping(uint256 => mapping(uint256 => bool)) internal _followerOnlyByPublicationByProfile;\n\n    /**\n     * @dev There is nothing needed at initialization.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        bool followerOnly = abi.decode(data, (bool));\n        if (followerOnly) _followerOnlyByPublicationByProfile[profileId][pubId] = true;\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower, if needed\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external view override {\n        if (_followerOnlyByPublicationByProfile[profileId][pubId])\n            _checkFollowValidity(profileId, collector);\n    }\n}\n"
    },
    "contracts/core/modules/collect/LimitedFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param collectLimit The maximum number of collects for this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param followerOnly Whether only followers should be able to collect.\n */\nstruct ProfilePublicationData {\n    uint256 collectLimit;\n    uint256 currentCollects;\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    bool followerOnly;\n}\n\n/**\n * @title LimitedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing limited collects for a publication indefinitely.\n */\ncontract LimitedFeeCollectModule is FeeModuleBase, FollowValidationModuleBase, ICollectModule {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The profile ID of the publication to initialize this module for's publishing profile.\n     * @param pubId The publication ID of the publication to initialize this module for.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 collectLimit: The maximum amount of collects.\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *      bool followerOnly: Whether only followers should be able to collect.\n     *\n     * @return bytes An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (\n            uint256 collectLimit,\n            uint256 amount,\n            address currency,\n            address recipient,\n            uint16 referralFee,\n            bool followerOnly\n        ) = abi.decode(data, (uint256, uint256, address, address, uint16, bool));\n        if (\n            collectLimit == 0 ||\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount == 0\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].collectLimit = collectLimit;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].followerOnly = followerOnly;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the collect does not pass the collect limit\n     *  3. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        if (_dataByPublicationByProfile[profileId][pubId].followerOnly)\n            _checkFollowValidity(profileId, collector);\n        if (\n            _dataByPublicationByProfile[profileId][pubId].currentCollects >=\n            _dataByPublicationByProfile[profileId][pubId].collectLimit\n        ) {\n            revert Errors.MintLimitExceeded();\n        } else {\n            ++_dataByPublicationByProfile[profileId][pubId].currentCollects;\n            if (referrerProfileId == profileId) {\n                _processCollect(collector, profileId, pubId, data);\n            } else {\n                _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return ProfilePublicationData The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n"
    },
    "contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param collectLimit The maximum number of collects for this publication.\n * @param currentCollects The current number of collects for this publication.\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param endTimestamp The end timestamp after which collecting is impossible.\n * @param followerOnly Whether only followers should be able to collect.\n */\nstruct ProfilePublicationData {\n    uint256 collectLimit;\n    uint256 currentCollects;\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    bool followerOnly;\n    uint40 endTimestamp;\n}\n\n/**\n * @title LimitedTimedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract. To optimize on gas, this module uses a constant 24 hour maximum\n * collection time.\n *\n * This module works by allowing limited collects for a publication within the allotted time with a given fee.\n */\ncontract LimitedTimedFeeCollectModule is FeeModuleBase, FollowValidationModuleBase, ICollectModule {\n    using SafeERC20 for IERC20;\n\n    uint24 internal constant ONE_DAY = 24 hours;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The profile ID of the publication to initialize this module for's publishing profile.\n     * @param pubId The publication ID of the publication to initialize this module for.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 collectLimit: The maximum amount of collects.\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *      bool followerOnly: Whether only followers should be able to collect.\n     *\n     * @return bytes An abi encoded bytes parameter, containing (in order): collectLimit, amount, currency, recipient, referral fee & end timestamp.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        unchecked {\n            uint40 endTimestamp = uint40(block.timestamp) + ONE_DAY;\n\n            (\n                uint256 collectLimit,\n                uint256 amount,\n                address currency,\n                address recipient,\n                uint16 referralFee,\n                bool followerOnly\n            ) = abi.decode(data, (uint256, uint256, address, address, uint16, bool));\n            if (\n                collectLimit == 0 ||\n                !_currencyWhitelisted(currency) ||\n                recipient == address(0) ||\n                referralFee > BPS_MAX ||\n                amount == 0\n            ) revert Errors.InitParamsInvalid();\n\n            _dataByPublicationByProfile[profileId][pubId].collectLimit = collectLimit;\n            _dataByPublicationByProfile[profileId][pubId].amount = amount;\n            _dataByPublicationByProfile[profileId][pubId].currency = currency;\n            _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n            _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n            _dataByPublicationByProfile[profileId][pubId].followerOnly = followerOnly;\n            _dataByPublicationByProfile[profileId][pubId].endTimestamp = endTimestamp;\n\n            return\n                abi.encode(\n                    collectLimit,\n                    amount,\n                    currency,\n                    recipient,\n                    referralFee,\n                    followerOnly,\n                    endTimestamp\n                );\n        }\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the current timestamp is less than or equal to the collect end timestamp\n     *  3. Ensuring the collect does not pass the collect limit\n     *  4. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        if (_dataByPublicationByProfile[profileId][pubId].followerOnly)\n            _checkFollowValidity(profileId, collector);\n        uint256 endTimestamp = _dataByPublicationByProfile[profileId][pubId].endTimestamp;\n        if (block.timestamp > endTimestamp) revert Errors.CollectExpired();\n\n        if (\n            _dataByPublicationByProfile[profileId][pubId].currentCollects >=\n            _dataByPublicationByProfile[profileId][pubId].collectLimit\n        ) {\n            revert Errors.MintLimitExceeded();\n        } else {\n            ++_dataByPublicationByProfile[profileId][pubId].currentCollects;\n            if (referrerProfileId == profileId) {\n                _processCollect(collector, profileId, pubId, data);\n            } else {\n                _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return ProfilepublicationData The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n"
    },
    "contracts/core/modules/collect/RevertCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\n\n/**\n * @title RevertCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface.\n *\n * This module works by disallowing all collects.\n */\ncontract RevertCollectModule is ICollectModule {\n    /**\n     * @dev There is nothing needed at initialization.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external pure override returns (bytes memory) {\n        return new bytes(0);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Always reverting\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external pure override {\n        revert Errors.CollectNotAllowed();\n    }\n}\n"
    },
    "contracts/core/modules/collect/TimedFeeCollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param currency The currency associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n * @param endTimestamp The end timestamp after which collecting is impossible.\n * @param followerOnly Whether only followers should be able to collect.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address currency;\n    address recipient;\n    uint16 referralFee;\n    bool followerOnly;\n    uint40 endTimestamp;\n}\n\n/**\n * @title TimedFeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract. To optimize on gas, this module uses a constant 24 hour maximum\n * collection time.\n *\n * This module works by allowing unlimited collects for a publication within the allotted time with a given fee.\n *\n * NOTE: If data passed on initialization is empty, this module will only check for the time limit.\n */\ncontract TimedFeeCollectModule is FeeModuleBase, FollowValidationModuleBase, ICollectModule {\n    using SafeERC20 for IERC20;\n\n    uint24 internal constant ONE_DAY = 24 hours;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The profile ID of the publication to initialize this module for's publishing profile.\n     * @param pubId The publication ID of the publication to initialize this module for.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *      bool followerOnly: Whether only followers should be able to collect.\n     *\n     * @return bytes An abi encoded bytes parameter, containing (in order): amount, currency, recipient, referral fee & end timestamp.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        unchecked {\n            uint40 endTimestamp = uint40(block.timestamp) + ONE_DAY;\n\n            (\n                uint256 amount,\n                address currency,\n                address recipient,\n                uint16 referralFee,\n                bool followerOnly\n            ) = abi.decode(data, (uint256, address, address, uint16, bool));\n            if (\n                !_currencyWhitelisted(currency) ||\n                recipient == address(0) ||\n                referralFee > BPS_MAX ||\n                amount == 0\n            ) revert Errors.InitParamsInvalid();\n\n            _dataByPublicationByProfile[profileId][pubId].amount = amount;\n            _dataByPublicationByProfile[profileId][pubId].currency = currency;\n            _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n            _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n            _dataByPublicationByProfile[profileId][pubId].followerOnly = followerOnly;\n            _dataByPublicationByProfile[profileId][pubId].endTimestamp = endTimestamp;\n\n            return abi.encode(amount, currency, recipient, referralFee, followerOnly, endTimestamp);\n        }\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Ensuring the current timestamp is less than or equal to the collect end timestamp\n     *  3. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub {\n        if (_dataByPublicationByProfile[profileId][pubId].followerOnly)\n            _checkFollowValidity(profileId, collector);\n        uint256 endTimestamp = _dataByPublicationByProfile[profileId][pubId].endTimestamp;\n        if (block.timestamp > endTimestamp) revert Errors.CollectExpired();\n\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return ProfilePublicationData The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n"
    },
    "contracts/core/modules/FeeModuleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Errors} from '../../libraries/Errors.sol';\nimport {Events} from '../../libraries/Events.sol';\nimport {IModuleGlobals} from '../../interfaces/IModuleGlobals.sol';\n\n/**\n * @title FeeModuleBase\n * @author Lens Protocol\n *\n * @notice This is an abstract contract to be inherited from by modules that require basic fee functionality. It\n * contains getters for module globals parameters as well as a validation function to check expected data.\n */\nabstract contract FeeModuleBase {\n    uint16 internal constant BPS_MAX = 10000;\n\n    address public immutable MODULE_GLOBALS;\n\n    constructor(address moduleGlobals) {\n        if (moduleGlobals == address(0)) revert Errors.InitParamsInvalid();\n        MODULE_GLOBALS = moduleGlobals;\n        emit Events.FeeModuleBaseConstructed(moduleGlobals, block.timestamp);\n    }\n\n    function _currencyWhitelisted(address currency) internal view returns (bool) {\n        return IModuleGlobals(MODULE_GLOBALS).isCurrencyWhitelisted(currency);\n    }\n\n    function _treasuryData() internal view returns (address, uint16) {\n        return IModuleGlobals(MODULE_GLOBALS).getTreasuryData();\n    }\n\n    function _validateDataIsExpected(\n        bytes calldata data,\n        address currency,\n        uint256 amount\n    ) internal pure {\n        (address decodedCurrency, uint256 decodedAmount) = abi.decode(data, (address, uint256));\n        if (decodedAmount != amount || decodedCurrency != currency)\n            revert Errors.ModuleDataMismatch();\n    }\n}\n"
    },
    "contracts/core/modules/follow/ApprovalFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {Events} from '../../../libraries/Events.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ApprovalFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n */\ncontract ApprovalFollowModule is FollowValidatorFollowModuleBase {\n    // We use a triple nested mapping so that, on profile transfer, the previous approved address list is invalid;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        internal _approvedByProfileByOwner;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice A custom function that allows profile owners to customize approved addresses.\n     *\n     * @param profileId The profile ID to approve/disapprove follower addresses for.\n     * @param addresses The addresses to approve/disapprove for following the profile.\n     * @param toApprove Whether to approve or disapprove the addresses for following the profile.\n     */\n    function approve(\n        uint256 profileId,\n        address[] calldata addresses,\n        bool[] calldata toApprove\n    ) external {\n        if (addresses.length != toApprove.length) revert Errors.InitParamsInvalid();\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (msg.sender != owner) revert Errors.NotProfileOwner();\n\n        uint256 addressesLength = addresses.length;\n        for (uint256 i = 0; i < addressesLength; ) {\n            _approvedByProfileByOwner[owner][profileId][addresses[i]] = toApprove[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Events.FollowsApproved(owner, profileId, addresses, toApprove, block.timestamp);\n    }\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param profileId The profile ID of the profile to initialize this module for.\n     * @param data The arbitrary data parameter, decoded into:\n     *      address[] addresses: The array of addresses to approve initially.\n     *\n     * @return bytes An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        address owner = IERC721(HUB).ownerOf(profileId);\n\n        if (data.length > 0) {\n            address[] memory addresses = abi.decode(data, (address[]));\n            uint256 addressesLength = addresses.length;\n            for (uint256 i = 0; i < addressesLength; ) {\n                _approvedByProfileByOwner[owner][profileId][addresses[i]] = true;\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower has been approved for that profile by the profile owner\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][follower])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][follower] = false; // prevents repeat follows\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns whether the given address is approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approval with.\n     * @param profileId The token ID of the profile to query approval with.\n     * @param toCheck The address to query approval for.\n     *\n     * @return bool True if the address is approved and false otherwise.\n     */\n    function isApproved(\n        address profileOwner,\n        uint256 profileId,\n        address toCheck\n    ) external view returns (bool) {\n        return _approvedByProfileByOwner[profileOwner][profileId][toCheck];\n    }\n\n    /**\n     * @notice Returns whether the given addresses are approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approvals with.\n     * @param profileId The token ID of the profile to query approvals with.\n     * @param toCheck The address array to query approvals for.\n     *\n     * @return bool[] true if the address at the specified index is approved and false otherwise.\n     */\n    function isApprovedArray(\n        address profileOwner,\n        uint256 profileId,\n        address[] calldata toCheck\n    ) external view returns (bool[] memory) {\n        bool[] memory approved = new bool[](toCheck.length);\n        uint256 toCheckLength = toCheck.length;\n        for (uint256 i = 0; i < toCheckLength; ) {\n            approved[i] = _approvedByProfileByOwner[profileOwner][profileId][toCheck[i]];\n            unchecked {\n                ++i;\n            }\n        }\n        return approved;\n    }\n}\n"
    },
    "contracts/core/modules/follow/FeeFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct ProfileData {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens FollowModule implementation, inheriting from the IFollowModule interface, but with additional\n * variables that can be controlled by governance, such as the governance & treasury addresses as well as the treasury fee.\n */\ncontract FeeFollowModule is FeeModuleBase, FollowValidatorFollowModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => ProfileData) internal _dataByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module levies a fee on follows.\n     *\n     * @param profileId The profile ID of the profile to initialize this module for.\n     * @param data The arbitrary data parameter, decoded into:\n     *      address currency: The currency address, must be internally whitelisted.\n     *      uint256 amount: The currency total amount to levy.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *\n     * @return bytes An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        (uint256 amount, address currency, address recipient) = abi.decode(\n            data,\n            (uint256, address, address)\n        );\n        if (!_currencyWhitelisted(currency) || recipient == address(0) || amount == 0)\n            revert Errors.InitParamsInvalid();\n\n        _dataByProfile[profileId].amount = amount;\n        _dataByProfile[profileId].currency = currency;\n        _dataByProfile[profileId].recipient = recipient;\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Charging a fee\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 amount = _dataByProfile[profileId].amount;\n        address currency = _dataByProfile[profileId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByProfile[profileId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns the profile data for a given profile, or an empty struct if that profile was not initialized\n     * with this module.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return ProfileData The ProfileData struct mapped to that profile.\n     */\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory) {\n        return _dataByProfile[profileId];\n    }\n}\n"
    },
    "contracts/core/modules/follow/FlowmiFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// 1. Pragma\npragma solidity 0.8.10;\n\n// 2. Imports\n// 2.1 VRF randomness creator\nimport '@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol';\nimport '@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol';\n// 2.2 Datafeed\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\nimport 'hardhat/console.sol';\nimport './PriceConverter.sol';\n// 2.3 Lens\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol'; // FeeFollowModule 0x60Ae865ee4C725cd04353b5AAb364553f56ceF82\nimport {ILensHub} from '../../../interfaces/ILensHub.sol'; //lens hub proxy 0x60Ae865ee4C725cd04353b5AAb364553f56ceF82\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n// Flowmi Logic Errors\nerror Flowmi__TransferFailed();\nerror Flowmi__SendMoreToEnterFlowmi();\nerror Flowmi__FlowmiRaffleNotOpen();\nerror Flowmi__MustBeRegisteredFlowmi();\nerror Flowmi__CantFlowmiFollowYourself();\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct ProfileData {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens FollowModule implementation, inheriting from the IFollowModule interface, but with additional\n * variables that can be controlled by governance, such as the governance & treasury addresses as well as the treasury fee.\n */\ncontract FlowmiFollowModule is VRFConsumerBaseV2, FeeModuleBase, FollowValidatorFollowModuleBase {\n    // Type Declarations\n    using PriceConverter for uint256;\n    enum RaffleState {\n        OPEN,\n        CALCULATING\n    }\n    RaffleState private s_raffleState;\n\n    // Events\n    event RequestSent(uint256 requestId, uint32 numWords);\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\n\n    // DataFeed\n    AggregatorV3Interface private i_priceFeed;\n\n    // VRF Coordinator\n    VRFCoordinatorV2Interface private i_vrfCoordinator;\n    bytes32 private immutable i_gasLane; // 500 gwei Key Hash;\n    uint32 private immutable i_callbackGasLimit;\n    uint64 private immutable i_subscriptionId;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    uint32 private constant NUM_WORDS = 1;\n\n    // VRF Requests\n    struct RequestStatus {\n        bool fulfilled; // whether the request has been successfully fulfilled\n        bool exists; // whether a requestId exists\n        uint256[] randomWords;\n    }\n    mapping(uint256 => RequestStatus) public s_requests; /* requestId --> requestStatus */\n    // past requests Id.\n    uint256[] public requestIds;\n    uint256 public lastRequestId;\n\n    // Lottery Variables\n    uint256 private immutable i_goal = 3;\n    uint256 private immutable i_flowmiCost = 1 * 10**17;\n    uint256 private immutable prize;\n    uint256 private s_index = 0;\n    uint256 private s_indexOfWinner;\n    address payable profileid;\n    address payable s_recentWinner;\n    address payable i_flowmiOwner;\n\n    mapping(address => mapping(uint256 => address payable)) private s_profileToFollowers; // mapping of profile to index to follower address\n    mapping(address => uint256) private s_profileToFollowersCount; // mapping to know the amount of followers an account has\n    mapping(address => uint256) private s_profileToFunds; // mapping to know how much funds has an account gathered\n    mapping(address => bool) private s_profileIsFlowmi; // mapping to know if an account is registered as flowmi\n    mapping(address => uint256) private s_profileToWins; // mapping to know how many times an account has won a raffle\n    mapping(address => uint256) private s_profileToRaffles; // mapping to know how many times an account has activated a raffle\n\n    // Lens\n    using SafeERC20 for IERC20;\n    mapping(uint256 => ProfileData) internal _dataByProfile;\n\n    //constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    constructor(\n        address priceFeed,\n        address vrfCoordinatorV2,\n        uint64 subscriptionId,\n        bytes32 gasLane, // keyHash\n        uint32 callbackGasLimit,\n        address hub,\n        address moduleGlobals\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) FeeModuleBase(moduleGlobals) ModuleBase(hub) {\n        i_priceFeed = AggregatorV3Interface(priceFeed);\n        i_flowmiOwner = payable(msg.sender);\n        prize = i_goal * i_flowmiCost;\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\n        s_raffleState = RaffleState.OPEN;\n        i_subscriptionId = subscriptionId;\n        i_gasLane = gasLane;\n        i_callbackGasLimit = callbackGasLimit;\n        s_indexOfWinner = 0;\n    }\n\n    //--------------------------Lens Module and Flowmi Logic-----------------------------------//\n\n    /**\n     * @notice This follow module levies a fee on follows.\n     *\n     * @param profileId The profile ID of the profile to initialize this module for.\n     * @param data The arbitrary data parameter, decoded into:\n     *      address currency: The currency address, must be internally whitelisted.\n     *      uint256 amount: The currency total amount to levy.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *\n     * @return bytes An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        (uint256 amount, address currency, address recipient) = abi.decode(\n            data,\n            (uint256, address, address)\n        );\n        if (!_currencyWhitelisted(currency) || recipient == address(0) || amount == 0)\n            revert Errors.InitParamsInvalid();\n\n        _dataByProfile[profileId].amount = amount;\n        _dataByProfile[profileId].currency = currency;\n        _dataByProfile[profileId].recipient = recipient;\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Charging a fee\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 amount = _dataByProfile[profileId].amount;\n        address currency = _dataByProfile[profileId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByProfile[profileId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        /* IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n        if (treasuryAmount > 0)\n            IERC20(currency).safeTransferFrom(\n                follower,\n                treasury,\n                treasuryAmount\n            );*/\n        profileid = payable(recipient);\n\n        // Check if profile to flowmiFollow is registered\n        if (!s_profileIsFlowmi[profileid]) {\n            revert Flowmi__MustBeRegisteredFlowmi();\n        }\n        // Check that you are not following yourself\n        if (follower == profileid) {\n            revert Flowmi__CantFlowmiFollowYourself();\n        }\n        // aqui msg.value podría ser amount\n        // Check the entrance fee is correct with Pricefeed for USD/Matic\n        if (amount.getConversionRate(i_priceFeed) < i_flowmiCost) {\n            revert Flowmi__SendMoreToEnterFlowmi();\n        }\n        // Reads previous amount of flowmiFollower\n        s_index = s_profileToFollowersCount[profileid];\n        // Update total amount of funds for profile\n        s_profileToFunds[profileid] += 1;\n        // Stores address as follower of profile\n        s_profileToFollowers[profileid][s_index] = payable(follower);\n        s_index++;\n        // Updates amount of flowmiFollowers\n        s_profileToFollowersCount[profileid] = s_index;\n\n        // If in goal, select a winner and call payment\n\n        if (s_index % i_goal == 0 && s_profileToFollowersCount[profileid] != 0) {\n            s_profileToRaffles[profileid]++;\n\n            requestRandomWords();\n        }\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns the profile data for a given profile, or an empty struct if that profile was not initialized\n     * with this module.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return ProfileData The ProfileData struct mapped to that profile.\n     */\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory) {\n        return _dataByProfile[profileId];\n    }\n\n    //--------------------------VRF and Flowmi Functions-----------------------------------//\n    // Internal VRF function to request a random word\n    // Raffle\n\n    modifier onlyOwner() {\n        require(msg.sender == i_flowmiOwner, 'Must be owner');\n        _;\n    }\n\n    // Assumes the subscription is funded sufficiently.\n    function requestRandomWords() internal returns (uint256 requestId) {\n        // Will revert if subscription is not set and funded.\n        requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        s_requests[requestId] = RequestStatus({\n            randomWords: new uint256[](0),\n            exists: true,\n            fulfilled: false\n        });\n        requestIds.push(requestId);\n        lastRequestId = requestId;\n        emit RequestSent(requestId, NUM_WORDS);\n        return requestId;\n    }\n\n    // Internal VRF function, receives the random word\n    // Here we make the payment\n\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords)\n        internal\n        override\n    {\n        require(s_requests[_requestId].exists, 'request not found');\n        s_requests[_requestId].fulfilled = true;\n        s_requests[_requestId].randomWords = _randomWords;\n        emit RequestFulfilled(_requestId, _randomWords);\n        s_indexOfWinner = (_randomWords[0] % i_goal);\n\n        s_indexOfWinner = s_profileToFollowersCount[profileid] - s_indexOfWinner - 1;\n\n        s_recentWinner = (s_profileToFollowers[profileid][s_indexOfWinner]);\n        s_profileToWins[s_recentWinner]++;\n        pay(s_recentWinner);\n    }\n\n    // Internal VRF function\n    function getRequestStatus(uint256 _requestId)\n        external\n        view\n        returns (bool fulfilled, uint256[] memory randomWords)\n    {\n        require(s_requests[_requestId].exists, 'request not found');\n        RequestStatus memory request = s_requests[_requestId];\n        return (request.fulfilled, request.randomWords);\n    }\n\n    /** @notice This function transfers, just to make it more difficult to hack\n     *  @param _winner is the address given by the mapping of followers in the index given by the VRF\n     */\n    function pay(address _winner) private {\n        (bool success, ) = _winner.call{value: prize}('');\n        if (!success) {\n            revert Flowmi__TransferFailed();\n        }\n    }\n\n    /** @notice This function registers a profile\n     */\n    function registerProfile() public {\n        s_profileIsFlowmi[msg.sender] = true;\n    }\n\n    /** @notice Let's you know if a profile is a flowmi registered profile\n     *  @param _profileid is the address of the profile\n     */\n    function isRegisteredProfile(address _profileid) public view returns (bool) {\n        return s_profileIsFlowmi[_profileid];\n    }\n\n    /** @notice Unregisters a profile making the mapping value false\n     */\n    function unregisterProfile() public {\n        s_profileIsFlowmi[msg.sender] = false;\n    }\n\n    /** @notice Let's you know how much is in aave protocol\n     */\n    function getPool() public onlyOwner {\n        //mapping de progiles [address] = true;\n    }\n\n    /** @notice Retrieve the goal of followers when the raffle is activated\n     * @return i_goal uint containing the goal\n     */\n    function getGoal() public pure returns (uint256) {\n        return i_goal;\n    }\n\n    /** @notice Get a 1 if the contract is deployed\n     * @return 1\n     */\n\n    function getFlowmiState() public pure returns (uint256) {\n        return 1;\n    }\n\n    /** @notice Get the flowmi follow cost\n     * @return i_flowmiCost cost in dollars\n     */\n\n    function getFlowmiCost() public pure returns (uint256) {\n        return i_flowmiCost;\n    }\n\n    /** @notice Gets the conversion in matic for 1 usd\n     * @return i_flowmiCost.getConversionRate(i_priceFeed)\n     */\n\n    function getPriceFeed() public view returns (uint256) {\n        return i_flowmiCost.getConversionRate(i_priceFeed);\n    }\n\n    /** @notice Gets the number of followers a profile has\n     * @param _profileid is the profile\n     * @return s_profileToFollowersCount of the profile\n     */\n\n    function getNumberOfFollowers(address _profileid) public view returns (uint256) {\n        return s_profileToFollowersCount[_profileid];\n    }\n\n    /** @notice Gets the address of a follower by index of flowmi follow\n     * @param _profileid is the profile requested\n     * @param _index is the index given to the follower when started flowmi following\n     * @return s_profileToFollowersCount in the profileid location\n     */\n    function getFollowerOfIndex(address _profileid, uint256 _index) public view returns (address) {\n        return s_profileToFollowers[_profileid][_index];\n    }\n\n    /** @notice Gets funds a profile has to give in the next raffle\n     * @param _profileid is the profile requested\n     * @return s_profileToFunds[_profileid] % i_goal, total amount of funds related to the profile\n     * \"modulo\" the goal of the raffle, so it only counts what haven't been raffled yet\n     */\n    function getFundsToRaffle(address _profileid) public view returns (uint256) {\n        return s_profileToFunds[_profileid] % i_goal;\n    }\n\n    /** @notice Gets total funds a profile has been given\n     * @param _profileid is the profile requested\n     * @return s_profileToFunds[_profileid], total amount of funds related to the profile\n     */\n\n    function getTotalFundedProfile(address _profileid) public view returns (uint256) {\n        return s_profileToFunds[_profileid];\n    }\n\n    /** @notice Gets total wins a profile has\n     * @param _profileid is the profile requested\n     * @return s_profileToWins[_profileid], total amount of raffles won\n     */\n\n    function getProfileToWins(address _profileid) public view returns (uint256) {\n        return s_profileToWins[_profileid];\n    }\n\n    /** @notice Gets total raffles a profile has made\n     * @param _profileid is the profile requested\n     * @return s_profileToRaffles[_profileid], total amount of raffles delivered\n     */\n\n    function getProfileToRaffles(address _profileid) public view returns (uint256) {\n        return s_profileToRaffles[_profileid];\n    }\n\n    /** @notice Gets the latest winner address\n     * @return s_recentWinner address of the last winner\n     */\n    function getLastWinnerAddress() public view returns (address) {\n        return s_recentWinner;\n    }\n\n    /** @notice Gets the latest winner index\n     * @return s_indexOfWinner index of the last winner\n     */\n    function getLastWinnerIndex() public view returns (uint256) {\n        return s_indexOfWinner;\n    }\n\n    /** @notice Gets the balance in the flowmi account\n     * @return balance\n     */\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /** @notice To be able to pay and fallback\n     */\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    /** @notice To witdraw the total amount of funds flowmi account has to the deployer\n     */\n    function withdraw() public onlyOwner {\n        (bool success, ) = i_flowmiOwner.call{value: address(this).balance}('');\n        require(success);\n    }\n}\n"
    },
    "contracts/core/modules/follow/FollowValidatorFollowModuleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title FollowValidatorFollowModuleBase\n * @author Lens Protocol\n *\n * @notice This abstract contract adds the default expected behavior for follow validation in a follow module\n * to inheriting contracts.\n */\nabstract contract FollowValidatorFollowModuleBase is ModuleBase, IFollowModule {\n    /**\n     * @notice Standard function to validate follow NFT ownership. This module is agnostic to follow NFT token IDs\n     * and other properties.\n     */\n    function isFollowing(\n        uint256 profileId,\n        address follower,\n        uint256 followNFTTokenId\n    ) external view override returns (bool) {\n        address followNFT = ILensHub(HUB).getFollowNFT(profileId);\n        if (followNFT == address(0)) {\n            return false;\n        } else {\n            return\n                followNFTTokenId == 0\n                    ? IERC721(followNFT).balanceOf(follower) != 0\n                    : IERC721(followNFT).ownerOf(followNFTTokenId) == follower;\n        }\n    }\n}\n"
    },
    "contracts/core/modules/follow/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n    function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        // ETH/USD rate in 18 digit\n        return uint256(answer * 10000000000);\n    }\n\n    // 1000000000\n    // call it get fiatConversionRate, since it assumes something about decimals\n    // It wouldn't work for every aggregator\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\n        // the actual ETH/USD conversation rate, after adjusting the extra 0s.\n        return ethAmountInUsd;\n    }\n}\n"
    },
    "contracts/core/modules/follow/ProfileFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ProfileFollowModule\n * @author Lens Protocol\n *\n * @notice A Lens Profile NFT token-gated follow module with single follow per token validation.\n */\ncontract ProfileFollowModule is FollowValidatorFollowModuleBase {\n    /**\n     * Given two profile IDs tells if the former has already been used to follow the latter.\n     */\n    mapping(uint256 => mapping(uint256 => bool)) public isProfileFollowing;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param profileId The profile ID of the profile to initialize this module for.\n     * @param data The arbitrary data parameter, which in this particular module initialization will be just ignored.\n     *\n     * @return bytes Empty bytes.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        return new bytes(0);\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower owns the profile passed through the data param.\n     *  2. Validating that the profile that is being used to execute the follow was not already used for following the\n     *     given profile.\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 followerProfileId = abi.decode(data, (uint256));\n        if (IERC721(HUB).ownerOf(followerProfileId) != follower) {\n            revert Errors.NotProfileOwner();\n        }\n        if (isProfileFollowing[followerProfileId][profileId]) {\n            revert Errors.FollowInvalid();\n        } else {\n            isProfileFollowing[followerProfileId][profileId] = true;\n        }\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n}\n"
    },
    "contracts/core/modules/follow/RevertFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\n\n/**\n * @title RevertFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module rejects all follow attempts.\n */\ncontract RevertFollowModule is FollowValidatorFollowModuleBase {\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param profileId The profile ID of the profile to initialize this module for.\n     * @param data The arbitrary data parameter, which in this particular module initialization will be just ignored.\n     *\n     * @return bytes Empty bytes.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        view\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        return new bytes(0);\n    }\n\n    /**\n     * @dev Processes a follow by rejecting it reverting the transaction.\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external view override onlyHub {\n        revert Errors.FollowInvalid();\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n}\n"
    },
    "contracts/core/modules/FollowValidationModuleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../interfaces/ILensHub.sol';\nimport {Errors} from '../../libraries/Errors.sol';\nimport {Events} from '../../libraries/Events.sol';\nimport {ModuleBase} from './ModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title FollowValidationModuleBase\n * @author Lens Protocol\n *\n * @notice This abstract contract adds a simple non-specific follow validation function.\n *\n * NOTE: Both the `HUB` variable and `_checkFollowValidity()` function are exposed to inheriting\n * contracts.\n *\n * NOTE: This is only compatible with COLLECT & REFERENCE MODULES.\n */\nabstract contract FollowValidationModuleBase is ModuleBase {\n    /**\n     * @notice Validates whether a given user is following a given profile.\n     *\n     * @dev It will revert if the user is not following the profile except the case when the user is the profile owner.\n     *\n     * @param profileId The ID of the profile that should be followed by the given user.\n     * @param user The address of the user that should be following the given profile.\n     */\n    function _checkFollowValidity(uint256 profileId, address user) internal view {\n        address followModule = ILensHub(HUB).getFollowModule(profileId);\n        bool isFollowing;\n        if (followModule != address(0)) {\n            isFollowing = IFollowModule(followModule).isFollowing(profileId, user, 0);\n        } else {\n            address followNFT = ILensHub(HUB).getFollowNFT(profileId);\n            isFollowing = followNFT != address(0) && IERC721(followNFT).balanceOf(user) != 0;\n        }\n        if (!isFollowing && IERC721(HUB).ownerOf(profileId) != user) {\n            revert Errors.FollowInvalid();\n        }\n    }\n}\n"
    },
    "contracts/core/modules/ModuleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Errors} from '../../libraries/Errors.sol';\nimport {Events} from '../../libraries/Events.sol';\n\n/**\n * @title ModuleBase\n * @author Lens Protocol\n *\n * @notice This abstract contract adds a public `HUB` immutable to inheriting modules, as well as an\n * `onlyHub` modifier.\n */\nabstract contract ModuleBase {\n    address public immutable HUB;\n\n    modifier onlyHub() {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        _;\n    }\n\n    constructor(address hub) {\n        if (hub == address(0)) revert Errors.InitParamsInvalid();\n        HUB = hub;\n        emit Events.ModuleBaseConstructed(hub, block.timestamp);\n    }\n}\n"
    },
    "contracts/core/modules/ModuleGlobals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Errors} from '../../libraries/Errors.sol';\nimport {Events} from '../../libraries/Events.sol';\nimport {IModuleGlobals} from '../../interfaces/IModuleGlobals.sol';\n\n/**\n * @title ModuleGlobals\n * @author Lens Protocol\n *\n * @notice This contract contains data relevant to Lens modules, such as the module governance address, treasury\n * address and treasury fee BPS.\n *\n * NOTE: The reason we have an additional governance address instead of just fetching it from the hub is to\n * allow the flexibility of using different governance executors.\n */\ncontract ModuleGlobals is IModuleGlobals {\n    uint16 internal constant BPS_MAX = 10000;\n\n    mapping(address => bool) internal _currencyWhitelisted;\n    address internal _governance;\n    address internal _treasury;\n    uint16 internal _treasuryFee;\n\n    modifier onlyGov() {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n        _;\n    }\n\n    /**\n     * @notice Initializes the governance, treasury and treasury fee amounts.\n     *\n     * @param governance The governance address which has additional control over setting certain parameters.\n     * @param treasury The treasury address to direct fees to.\n     * @param treasuryFee The treasury fee in BPS to levy on collects.\n     */\n    constructor(\n        address governance,\n        address treasury,\n        uint16 treasuryFee\n    ) {\n        _setGovernance(governance);\n        _setTreasury(treasury);\n        _setTreasuryFee(treasuryFee);\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function setTreasury(address newTreasury) external override onlyGov {\n        _setTreasury(newTreasury);\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function setTreasuryFee(uint16 newTreasuryFee) external override onlyGov {\n        _setTreasuryFee(newTreasuryFee);\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function whitelistCurrency(address currency, bool toWhitelist) external override onlyGov {\n        _whitelistCurrency(currency, toWhitelist);\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function isCurrencyWhitelisted(address currency) external view override returns (bool) {\n        return _currencyWhitelisted[currency];\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    /// @inheritdoc IModuleGlobals\n    function getTreasuryFee() external view override returns (uint16) {\n        return _treasuryFee;\n    }\n\n    //@inheritdoc IModuleGlobals\n    function getTreasuryData() external view override returns (address, uint16) {\n        return (_treasury, _treasuryFee);\n    }\n\n    function _setGovernance(address newGovernance) internal {\n        if (newGovernance == address(0)) revert Errors.InitParamsInvalid();\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.ModuleGlobalsGovernanceSet(prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _setTreasury(address newTreasury) internal {\n        if (newTreasury == address(0)) revert Errors.InitParamsInvalid();\n        address prevTreasury = _treasury;\n        _treasury = newTreasury;\n        emit Events.ModuleGlobalsTreasurySet(prevTreasury, newTreasury, block.timestamp);\n    }\n\n    function _setTreasuryFee(uint16 newTreasuryFee) internal {\n        if (newTreasuryFee >= BPS_MAX / 2) revert Errors.InitParamsInvalid();\n        uint16 prevTreasuryFee = _treasuryFee;\n        _treasuryFee = newTreasuryFee;\n        emit Events.ModuleGlobalsTreasuryFeeSet(prevTreasuryFee, newTreasuryFee, block.timestamp);\n    }\n\n    function _whitelistCurrency(address currency, bool toWhitelist) internal {\n        if (currency == address(0)) revert Errors.InitParamsInvalid();\n        bool prevWhitelisted = _currencyWhitelisted[currency];\n        _currencyWhitelisted[currency] = toWhitelist;\n        emit Events.ModuleGlobalsCurrencyWhitelisted(\n            currency,\n            prevWhitelisted,\n            toWhitelist,\n            block.timestamp\n        );\n    }\n}\n"
    },
    "contracts/core/modules/reference/FollowerOnlyReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IReferenceModule} from '../../../interfaces/IReferenceModule.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title FollowerOnlyReferenceModule\n * @author Lens Protocol\n *\n * @notice A simple reference module that validates that comments or mirrors originate from a profile owned\n * by a follower.\n */\ncontract FollowerOnlyReferenceModule is FollowValidationModuleBase, IReferenceModule {\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @dev There is nothing needed at initialization.\n     */\n    function initializeReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external pure override returns (bytes memory) {\n        return new bytes(0);\n    }\n\n    /**\n     * @notice Validates that the commenting profile's owner is a follower.\n     *\n     * NOTE: We don't need to care what the pointed publication is in this context.\n     */\n    function processComment(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes calldata data\n    ) external view override {\n        address commentCreator = IERC721(HUB).ownerOf(profileId);\n        _checkFollowValidity(profileIdPointed, commentCreator);\n    }\n\n    /**\n     * @notice Validates that the commenting profile's owner is a follower.\n     *\n     * NOTE: We don't need to care what the pointed publication is in this context.\n     */\n    function processMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes calldata data\n    ) external view override {\n        address mirrorCreator = IERC721(HUB).ownerOf(profileId);\n        _checkFollowValidity(profileIdPointed, mirrorCreator);\n    }\n}\n"
    },
    "contracts/core/storage/LensHubStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../../libraries/DataTypes.sol';\n\n/**\n * @title LensHubStorage\n * @author Lens Protocol\n *\n * @notice This is an abstract contract that *only* contains storage for the LensHub contract. This\n * *must* be inherited last (bar interfaces) in order to preserve the LensHub storage layout. Adding\n * storage variables should be done solely at the bottom of this contract.\n */\nabstract contract LensHubStorage {\n    bytes32 internal constant SET_DEFAULT_PROFILE_WITH_SIG_TYPEHASH =\n        keccak256(\n            'SetDefaultProfileWithSig(address wallet,uint256 profileId,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH =\n        keccak256(\n            'SetFollowModuleWithSig(uint256 profileId,address followModule,bytes followModuleInitData,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH =\n        keccak256(\n            'SetFollowNFTURIWithSig(uint256 profileId,string followNFTURI,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant SET_DISPATCHER_WITH_SIG_TYPEHASH =\n        keccak256(\n            'SetDispatcherWithSig(uint256 profileId,address dispatcher,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH =\n        keccak256(\n            'SetProfileImageURIWithSig(uint256 profileId,string imageURI,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant POST_WITH_SIG_TYPEHASH =\n        keccak256(\n            'PostWithSig(uint256 profileId,string contentURI,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant COMMENT_WITH_SIG_TYPEHASH =\n        keccak256(\n            'CommentWithSig(uint256 profileId,string contentURI,uint256 profileIdPointed,uint256 pubIdPointed,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant MIRROR_WITH_SIG_TYPEHASH =\n        keccak256(\n            'MirrorWithSig(uint256 profileId,uint256 profileIdPointed,uint256 pubIdPointed,bytes referenceModuleData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant FOLLOW_WITH_SIG_TYPEHASH =\n        keccak256(\n            'FollowWithSig(uint256[] profileIds,bytes[] datas,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant COLLECT_WITH_SIG_TYPEHASH =\n        keccak256(\n            'CollectWithSig(uint256 profileId,uint256 pubId,bytes data,uint256 nonce,uint256 deadline)'\n        );\n\n    mapping(address => bool) internal _profileCreatorWhitelisted;\n    mapping(address => bool) internal _followModuleWhitelisted;\n    mapping(address => bool) internal _collectModuleWhitelisted;\n    mapping(address => bool) internal _referenceModuleWhitelisted;\n\n    mapping(uint256 => address) internal _dispatcherByProfile;\n    mapping(bytes32 => uint256) internal _profileIdByHandleHash;\n    mapping(uint256 => DataTypes.ProfileStruct) internal _profileById;\n    mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct)) internal _pubByIdByProfile;\n\n    mapping(address => uint256) internal _defaultProfileByAddress;\n\n    uint256 internal _profileCounter;\n    address internal _governance;\n    address internal _emergencyAdmin;\n}\n"
    },
    "contracts/interfaces/ICollectModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @title ICollectModule\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible CollectModules.\n */\ninterface ICollectModule {\n    /**\n     * @notice Initializes data for a given publication being published. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     * @param data Arbitrary data __passed from the user!__ to be decoded.\n     *\n     * @return bytes An abi encoded byte array encapsulating the execution's state changes. This will be emitted by the\n     * hub alongside the collect module's address and should be consumed by front ends.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a collect action for a given publication, this can only be called by the hub.\n     *\n     * @param referrerProfileId The LensHub profile token ID of the referrer's profile (only different in case of mirrors).\n     * @param collector The collector address.\n     * @param profileId The token ID of the profile associated with the publication being collected.\n     * @param pubId The LensHub publication ID associated with the publication being collected.\n     * @param data Arbitrary data __passed from the collector!__ to be decoded.\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ICollectNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @title ICollectNFT\n * @author Lens Protocol\n *\n * @notice This is the interface for the CollectNFT contract. Which is cloned upon the first collect for any given\n * publication.\n */\ninterface ICollectNFT {\n    /**\n     * @notice Initializes the collect NFT, setting the feed as the privileged minter, storing the collected publication pointer\n     * and initializing the name and symbol in the LensNFTBase contract.\n     *\n     * @param profileId The token ID of the profile in the hub that this collectNFT points to.\n     * @param pubId The profile publication ID in the hub that this collectNFT points to.\n     * @param name The name to set for this NFT.\n     * @param symbol The symbol to set for this NFT.\n     */\n    function initialize(\n        uint256 profileId,\n        uint256 pubId,\n        string calldata name,\n        string calldata symbol\n    ) external;\n\n    /**\n     * @notice Mints a collect NFT to the specified address. This can only be called by the hub, and is called\n     * upon collection.\n     *\n     * @param to The address to mint the NFT to.\n     *\n     * @return uint256 An interger representing the minted token ID.\n     */\n    function mint(address to) external returns (uint256);\n\n    /**\n     * @notice Returns the source publication pointer mapped to this collect NFT.\n     *\n     * @return tuple First the profile ID uint256, and second the pubId uint256.\n     */\n    function getSourcePublicationPointer() external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @title IFollowModule\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible FollowModules.\n */\ninterface IFollowModule {\n    /**\n     * @notice Initializes a follow module for a given Lens profile. This can only be called by the hub contract.\n     *\n     * @param profileId The token ID of the profile to initialize this follow module for.\n     * @param data Arbitrary data passed by the profile creator.\n     *\n     * @return bytes The encoded data to emit in the hub.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        returns (bytes memory);\n\n    /**\n     * @notice Processes a given follow, this can only be called from the LensHub contract.\n     *\n     * @param follower The follower address.\n     * @param profileId The token ID of the profile being followed.\n     * @param data Arbitrary data passed by the follower.\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice This is a transfer hook that is called upon follow NFT transfer in `beforeTokenTransfer. This can\n     * only be called from the LensHub contract.\n     *\n     * NOTE: Special care needs to be taken here: It is possible that follow NFTs were issued before this module\n     * was initialized if the profile's follow module was previously different. This transfer hook should take this\n     * into consideration, especially when the module holds state associated with individual follow NFTs.\n     *\n     * @param profileId The token ID of the profile associated with the follow NFT being transferred.\n     * @param from The address sending the follow NFT.\n     * @param to The address receiving the follow NFT.\n     * @param followNFTTokenId The token ID of the follow NFT being transferred.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external;\n\n    /**\n     * @notice This is a helper function that could be used in conjunction with specific collect modules.\n     *\n     * NOTE: This function IS meant to replace a check on follower NFT ownership.\n     *\n     * NOTE: It is assumed that not all collect modules are aware of the token ID to pass. In these cases,\n     * this should receive a `followNFTTokenId` of 0, which is impossible regardless.\n     *\n     * One example of a use case for this would be a subscription-based following system:\n     *      1. The collect module:\n     *          - Decodes a follower NFT token ID from user-passed data.\n     *          - Fetches the follow module from the hub.\n     *          - Calls `isFollowing` passing the profile ID, follower & follower token ID and checks it returned true.\n     *      2. The follow module:\n     *          - Validates the subscription status for that given NFT, reverting on an invalid subscription.\n     *\n     * @param profileId The token ID of the profile to validate the follow for.\n     * @param follower The follower address to validate the follow for.\n     * @param followNFTTokenId The followNFT token ID to validate the follow for.\n     *\n     * @return true if the given address is following the given profile ID, false otherwise.\n     */\n    function isFollowing(\n        uint256 profileId,\n        address follower,\n        uint256 followNFTTokenId\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IFollowNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../libraries/DataTypes.sol';\n\n/**\n * @title IFollowNFT\n * @author Lens Protocol\n *\n * @notice This is the interface for the FollowNFT contract, which is cloned upon the first follow for any profile.\n */\ninterface IFollowNFT {\n    /**\n     * @notice Initializes the follow NFT, setting the hub as the privileged minter and storing the associated profile ID.\n     *\n     * @param profileId The token ID of the profile in the hub associated with this followNFT, used for transfer hooks.\n     */\n    function initialize(uint256 profileId) external;\n\n    /**\n     * @notice Mints a follow NFT to the specified address. This can only be called by the hub, and is called\n     * upon follow.\n     *\n     * @param to The address to mint the NFT to.\n     *\n     * @return uint256 An interger representing the minted token ID.\n     */\n    function mint(address to) external returns (uint256);\n\n    /**\n     * @notice Delegates the caller's governance power to the given delegatee address.\n     *\n     * @param delegatee The delegatee address to delegate governance power to.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @notice Delegates the delegator's governance power via meta-tx to the given delegatee address.\n     *\n     * @param delegator The delegator address, who is the signer.\n     * @param delegatee The delegatee address, who is receiving the governance power delegation.\n     * @param sig The EIP712Signature struct containing the necessary parameters to recover the delegator's signature.\n     */\n    function delegateBySig(\n        address delegator,\n        address delegatee,\n        DataTypes.EIP712Signature calldata sig\n    ) external;\n\n    /**\n     * @notice Returns the governance power for a given user at a specified block number.\n     *\n     * @param user The user to query governance power for.\n     * @param blockNumber The block number to query the user's governance power at.\n     *\n     * @return uint256 The power of the given user at the given block number.\n     */\n    function getPowerByBlockNumber(address user, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @notice Returns the total delegated supply at a specified block number. This is the sum of all\n     * current available voting power at a given block.\n     *\n     * @param blockNumber The block number to query the delegated supply at.\n     *\n     * @return uint256 The delegated supply at the given block number.\n     */\n    function getDelegatedSupplyByBlockNumber(uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILensHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../libraries/DataTypes.sol';\n\n/**\n * @title ILensHub\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensHub contract, the main entry point for the Lens Protocol.\n * You'll find all the events and external functions, as well as the reasoning behind them here.\n */\ninterface ILensHub {\n    /**\n     * @notice Initializes the LensHub NFT, setting the initial governance address as well as the name and symbol in\n     * the LensNFTBase contract.\n     *\n     * @param name The name to set for the hub NFT.\n     * @param symbol The symbol to set for the hub NFT.\n     * @param newGovernance The governance address to set.\n     */\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external;\n\n    /**\n     * @notice Sets the privileged governance role. This function can only be called by the current governance\n     * address.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external;\n\n    /**\n     * @notice Sets the emergency admin, which is a permissioned role able to set the protocol state. This function\n     * can only be called by the governance address.\n     *\n     * @param newEmergencyAdmin The new emergency admin address to set.\n     */\n    function setEmergencyAdmin(address newEmergencyAdmin) external;\n\n    /**\n     * @notice Sets the protocol state to either a global pause, a publishing pause or an unpaused state. This function\n     * can only be called by the governance address or the emergency admin address.\n     *\n     * Note that this reverts if the emergency admin calls it if:\n     *      1. The emergency admin is attempting to unpause.\n     *      2. The emergency admin is calling while the protocol is already paused.\n     *\n     * @param newState The state to set, as a member of the ProtocolState enum.\n     */\n    function setState(DataTypes.ProtocolState newState) external;\n\n    /**\n     * @notice Adds or removes a profile creator from the whitelist. This function can only be called by the current\n     * governance address.\n     *\n     * @param profileCreator The profile creator address to add or remove from the whitelist.\n     * @param whitelist Whether or not the profile creator should be whitelisted.\n     */\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external;\n\n    /**\n     * @notice Adds or removes a follow module from the whitelist. This function can only be called by the current\n     * governance address.\n     *\n     * @param followModule The follow module contract address to add or remove from the whitelist.\n     * @param whitelist Whether or not the follow module should be whitelisted.\n     */\n    function whitelistFollowModule(address followModule, bool whitelist) external;\n\n    /**\n     * @notice Adds or removes a reference module from the whitelist. This function can only be called by the current\n     * governance address.\n     *\n     * @param referenceModule The reference module contract to add or remove from the whitelist.\n     * @param whitelist Whether or not the reference module should be whitelisted.\n     */\n    function whitelistReferenceModule(address referenceModule, bool whitelist) external;\n\n    /**\n     * @notice Adds or removes a collect module from the whitelist. This function can only be called by the current\n     * governance address.\n     *\n     * @param collectModule The collect module contract address to add or remove from the whitelist.\n     * @param whitelist Whether or not the collect module should be whitelisted.\n     */\n    function whitelistCollectModule(address collectModule, bool whitelist) external;\n\n    /**\n     * @notice Creates a profile with the specified parameters, minting a profile NFT to the given recipient. This\n     * function must be called by a whitelisted profile creator.\n     *\n     * @param vars A CreateProfileData struct containing the following params:\n     *      to: The address receiving the profile.\n     *      handle: The handle to set for the profile, must be unique and non-empty.\n     *      imageURI: The URI to set for the profile image.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleInitData: The follow module initialization data, if any.\n     */\n    function createProfile(DataTypes.CreateProfileData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Sets the mapping between wallet and its main profile identity.\n     *\n     * @param profileId The token ID of the profile to set as the main profile identity.\n     */\n    function setDefaultProfile(uint256 profileId) external;\n\n    /**\n     * @notice Sets the mapping between wallet and its main profile identity via signature with the specified parameters.\n     *\n     * @param vars A SetDefaultProfileWithSigData struct, including the regular parameters and an EIP712Signature struct.\n     */\n    function setDefaultProfileWithSig(DataTypes.SetDefaultProfileWithSigData calldata vars)\n        external;\n\n    /**\n     * @notice Sets a profile's follow module, must be called by the profile owner.\n     *\n     * @param profileId The token ID of the profile to set the follow module for.\n     * @param followModule The follow module to set for the given profile, must be whitelisted.\n     * @param followModuleInitData The data to be passed to the follow module for initialization.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external;\n\n    /**\n     * @notice Sets a profile's follow module via signature with the specified parameters.\n     *\n     * @param vars A SetFollowModuleWithSigData struct, including the regular parameters and an EIP712Signature struct.\n     */\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars) external;\n\n    /**\n     * @notice Sets a profile's dispatcher, giving that dispatcher rights to publish to that profile.\n     *\n     * @param profileId The token ID of the profile of the profile to set the dispatcher for.\n     * @param dispatcher The dispatcher address to set for the given profile ID.\n     */\n    function setDispatcher(uint256 profileId, address dispatcher) external;\n\n    /**\n     * @notice Sets a profile's dispatcher via signature with the specified parameters.\n     *\n     * @param vars A SetDispatcherWithSigData struct, including the regular parameters and an EIP712Signature struct.\n     */\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars) external;\n\n    /**\n     * @notice Sets a profile's URI, which is reflected in the `tokenURI()` function.\n     *\n     * @param profileId The token ID of the profile of the profile to set the URI for.\n     * @param imageURI The URI to set for the given profile.\n     */\n    function setProfileImageURI(uint256 profileId, string calldata imageURI) external;\n\n    /**\n     * @notice Sets a profile's URI via signature with the specified parameters.\n     *\n     * @param vars A SetProfileImageURIWithSigData struct, including the regular parameters and an EIP712Signature struct.\n     */\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external;\n\n    /**\n     * @notice Sets a followNFT URI for a given profile's follow NFT.\n     *\n     * @param profileId The token ID of the profile for which to set the followNFT URI.\n     * @param followNFTURI The follow NFT URI to set.\n     */\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI) external;\n\n    /**\n     * @notice Sets a followNFT URI via signature with the specified parameters.\n     *\n     * @param vars A SetFollowNFTURIWithSigData struct, including the regular parameters and an EIP712Signature struct.\n     */\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars) external;\n\n    /**\n     * @notice Publishes a post to a given profile, must be called by the profile owner.\n     *\n     * @param vars A PostData struct containing the needed parameters.\n     *\n     * @return uint256 An integer representing the post's publication ID.\n     */\n    function post(DataTypes.PostData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Publishes a post to a given profile via signature with the specified parameters.\n     *\n     * @param vars A PostWithSigData struct containing the regular parameters and an EIP712Signature struct.\n     *\n     * @return uint256 An integer representing the post's publication ID.\n     */\n    function postWithSig(DataTypes.PostWithSigData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Publishes a comment to a given profile, must be called by the profile owner.\n     *\n     * @param vars A CommentData struct containing the needed parameters.\n     *\n     * @return uint256 An integer representing the comment's publication ID.\n     */\n    function comment(DataTypes.CommentData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Publishes a comment to a given profile via signature with the specified parameters.\n     *\n     * @param vars A CommentWithSigData struct containing the regular parameters and an EIP712Signature struct.\n     *\n     * @return uint256 An integer representing the comment's publication ID.\n     */\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Publishes a mirror to a given profile, must be called by the profile owner.\n     *\n     * @param vars A MirrorData struct containing the necessary parameters.\n     *\n     * @return uint256 An integer representing the mirror's publication ID.\n     */\n    function mirror(DataTypes.MirrorData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Publishes a mirror to a given profile via signature with the specified parameters.\n     *\n     * @param vars A MirrorWithSigData struct containing the regular parameters and an EIP712Signature struct.\n     *\n     * @return uint256 An integer representing the mirror's publication ID.\n     */\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars) external returns (uint256);\n\n    /**\n     * @notice Follows the given profiles, executing each profile's follow module logic (if any) and minting followNFTs to the caller.\n     *\n     * NOTE: Both the `profileIds` and `datas` arrays must be of the same length, regardless if the profiles do not have a follow module set.\n     *\n     * @param profileIds The token ID array of the profiles to follow.\n     * @param datas The arbitrary data array to pass to the follow module for each profile if needed.\n     *\n     * @return uint256[] An array of integers representing the minted follow NFTs token IDs.\n     */\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        returns (uint256[] memory);\n\n    /**\n     * @notice Follows a given profile via signature with the specified parameters.\n     *\n     * @param vars A FollowWithSigData struct containing the regular parameters as well as the signing follower's address\n     * and an EIP712Signature struct.\n     *\n     * @return uint256[] An array of integers representing the minted follow NFTs token IDs.\n     */\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        returns (uint256[] memory);\n\n    /**\n     * @notice Collects a given publication, executing collect module logic and minting a collectNFT to the caller.\n     *\n     * @param profileId The token ID of the profile that published the publication to collect.\n     * @param pubId The publication to collect's publication ID.\n     * @param data The arbitrary data to pass to the collect module if needed.\n     *\n     * @return uint256 An integer representing the minted token ID.\n     */\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Collects a given publication via signature with the specified parameters.\n     *\n     * @param vars A CollectWithSigData struct containing the regular parameters as well as the collector's address and\n     * an EIP712Signature struct.\n     *\n     * @return uint256 An integer representing the minted token ID.\n     */\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars) external returns (uint256);\n\n    /**\n     * @dev Helper function to emit a detailed followNFT transfer event from the hub, to be consumed by frontends to track\n     * followNFT transfers.\n     *\n     * @param profileId The token ID of the profile associated with the followNFT being transferred.\n     * @param followNFTId The followNFT being transferred's token ID.\n     * @param from The address the followNFT is being transferred from.\n     * @param to The address the followNFT is being transferred to.\n     */\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external;\n\n    /**\n     * @dev Helper function to emit a detailed collectNFT transfer event from the hub, to be consumed by frontends to track\n     * collectNFT transfers.\n     *\n     * @param profileId The token ID of the profile associated with the collect NFT being transferred.\n     * @param pubId The publication ID associated with the collect NFT being transferred.\n     * @param collectNFTId The collectNFT being transferred's token ID.\n     * @param from The address the collectNFT is being transferred from.\n     * @param to The address the collectNFT is being transferred to.\n     */\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external;\n\n    /// ************************\n    /// *****VIEW FUNCTIONS*****\n    /// ************************\n\n    /**\n     * @notice Returns whether or not a profile creator is whitelisted.\n     *\n     * @param profileCreator The address of the profile creator to check.\n     *\n     * @return bool True if the profile creator is whitelisted, false otherwise.\n     */\n    function isProfileCreatorWhitelisted(address profileCreator) external view returns (bool);\n\n    /**\n     * @notice Returns default profile for a given wallet address\n     *\n     * @param wallet The address to find the default mapping\n     *\n     * @return uint256 The default profile id, which will be 0 if not mapped.\n     */\n    function defaultProfile(address wallet) external view returns (uint256);\n\n    /**\n     * @notice Returns whether or not a follow module is whitelisted.\n     *\n     * @param followModule The address of the follow module to check.\n     *\n     * @return bool True if the the follow module is whitelisted, false otherwise.\n     */\n    function isFollowModuleWhitelisted(address followModule) external view returns (bool);\n\n    /**\n     * @notice Returns whether or not a reference module is whitelisted.\n     *\n     * @param referenceModule The address of the reference module to check.\n     *\n     * @return bool True if the the reference module is whitelisted, false otherwise.\n     */\n    function isReferenceModuleWhitelisted(address referenceModule) external view returns (bool);\n\n    /**\n     * @notice Returns whether or not a collect module is whitelisted.\n     *\n     * @param collectModule The address of the collect module to check.\n     *\n     * @return bool True if the the collect module is whitelisted, false otherwise.\n     */\n    function isCollectModuleWhitelisted(address collectModule) external view returns (bool);\n\n    /**\n     * @notice Returns the currently configured governance address.\n     *\n     * @return address The address of the currently configured governance.\n     */\n    function getGovernance() external view returns (address);\n\n    /**\n     * @notice Returns the dispatcher associated with a profile.\n     *\n     * @param profileId The token ID of the profile to query the dispatcher for.\n     *\n     * @return address The dispatcher address associated with the profile.\n     */\n    function getDispatcher(uint256 profileId) external view returns (address);\n\n    /**\n     * @notice Returns the publication count for a given profile.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return uint256 The number of publications associated with the queried profile.\n     */\n    function getPubCount(uint256 profileId) external view returns (uint256);\n\n    /**\n     * @notice Returns the followNFT associated with a given profile, if any.\n     *\n     * @param profileId The token ID of the profile to query the followNFT for.\n     *\n     * @return address The followNFT associated with the given profile.\n     */\n    function getFollowNFT(uint256 profileId) external view returns (address);\n\n    /**\n     * @notice Returns the followNFT URI associated with a given profile.\n     *\n     * @param profileId The token ID of the profile to query the followNFT URI for.\n     *\n     * @return string The followNFT URI associated with the given profile.\n     */\n    function getFollowNFTURI(uint256 profileId) external view returns (string memory);\n\n    /**\n     * @notice Returns the collectNFT associated with a given publication, if any.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return address The address of the collectNFT associated with the queried publication.\n     */\n    function getCollectNFT(uint256 profileId, uint256 pubId) external view returns (address);\n\n    /**\n     * @notice Returns the follow module associated witha  given profile, if any.\n     *\n     * @param profileId The token ID of the profile to query the follow module for.\n     *\n     * @return address The address of the follow module associated with the given profile.\n     */\n    function getFollowModule(uint256 profileId) external view returns (address);\n\n    /**\n     * @notice Returns the collect module associated with a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return address The address of the collect module associated with the queried publication.\n     */\n    function getCollectModule(uint256 profileId, uint256 pubId) external view returns (address);\n\n    /**\n     * @notice Returns the reference module associated witha  given profile, if any.\n     *\n     * @param profileId The token ID of the profile that published the publication to querythe reference module for.\n     * @param pubId The publication ID of the publication to query the reference module for.\n     *\n     * @return address The address of the reference module associated with the given profile.\n     */\n    function getReferenceModule(uint256 profileId, uint256 pubId) external view returns (address);\n\n    /**\n     * @notice Returns the handle associated with a profile.\n     *\n     * @param profileId The token ID of the profile to query the handle for.\n     *\n     * @return string The handle associated with the profile.\n     */\n    function getHandle(uint256 profileId) external view returns (string memory);\n\n    /**\n     * @notice Returns the publication pointer (profileId & pubId) associated with a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query the pointer for.\n     * @param pubId The publication ID of the publication to query the pointer for.\n     *\n     * @return tuple First, the profile ID of the profile the current publication is pointing to, second, the\n     * publication ID of the publication the current publication is pointing to.\n     */\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (uint256, uint256);\n\n    /**\n     * @notice Returns the URI associated with a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return string The URI associated with a given publication.\n     */\n    function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory);\n\n    /**\n     * @notice Returns the profile token ID according to a given handle.\n     *\n     * @param handle The handle to resolve the profile token ID with.\n     *\n     * @return uint256 The profile ID the passed handle points to.\n     */\n    function getProfileIdByHandle(string calldata handle) external view returns (uint256);\n\n    /**\n     * @notice Returns the full profile struct associated with a given profile token ID.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return ProfileStruct The profile struct of the given profile.\n     */\n    function getProfile(uint256 profileId) external view returns (DataTypes.ProfileStruct memory);\n\n    /**\n     * @notice Returns the full publication struct for a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return PublicationStruct The publication struct associated with the queried publication.\n     */\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (DataTypes.PublicationStruct memory);\n\n    /**\n     * @notice Returns the publication type associated with a given publication.\n     *\n     * @param profileId The token ID of the profile that published the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return PubType The publication type, as a member of an enum (either \"post,\" \"comment\" or \"mirror\").\n     */\n    function getPubType(uint256 profileId, uint256 pubId) external view returns (DataTypes.PubType);\n\n    /**\n     * @notice Returns the follow NFT implementation address.\n     *\n     * @return address The follow NFT implementation address.\n     */\n    function getFollowNFTImpl() external view returns (address);\n\n    /**\n     * @notice Returns the collect NFT implementation address.\n     *\n     * @return address The collect NFT implementation address.\n     */\n    function getCollectNFTImpl() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILensNFTBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../libraries/DataTypes.sol';\n\n/**\n * @title ILensNFTBase\n * @author Lens Protocol\n *\n * @notice This is the interface for the LensNFTBase contract, from which all Lens NFTs inherit.\n * It is an expansion of a very slightly modified ERC721Enumerable contract, which allows expanded\n * meta-transaction functionality.\n */\ninterface ILensNFTBase {\n    /**\n     * @notice Implementation of an EIP-712 permit function for an ERC-721 NFT. We don't need to check\n     * if the tokenId exists, since the function calls ownerOf(tokenId), which reverts if the tokenId does\n     * not exist.\n     *\n     * @param spender The NFT spender.\n     * @param tokenId The NFT token ID to approve.\n     * @param sig The EIP712 signature struct.\n     */\n    function permit(\n        address spender,\n        uint256 tokenId,\n        DataTypes.EIP712Signature calldata sig\n    ) external;\n\n    /**\n     * @notice Implementation of an EIP-712 permit-style function for ERC-721 operator approvals. Allows\n     * an operator address to control all NFTs a given owner owns.\n     *\n     * @param owner The owner to set operator approvals for.\n     * @param operator The operator to approve.\n     * @param approved Whether to approve or revoke approval from the operator.\n     * @param sig The EIP712 signature struct.\n     */\n    function permitForAll(\n        address owner,\n        address operator,\n        bool approved,\n        DataTypes.EIP712Signature calldata sig\n    ) external;\n\n    /**\n     * @notice Burns an NFT, removing it from circulation and essentially destroying it. This function can only\n     * be called by the NFT to burn's owner.\n     *\n     * @param tokenId The token ID of the token to burn.\n     */\n    function burn(uint256 tokenId) external;\n\n    /**\n     * @notice Implementation of an EIP-712 permit-style function for token burning. Allows anyone to burn\n     * a token on behalf of the owner with a signature.\n     *\n     * @param tokenId The token ID of the token to burn.\n     * @param sig The EIP712 signature struct.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig) external;\n\n    /**\n     * @notice Returns the domain separator for this NFT contract.\n     *\n     * @return bytes32 The domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IModuleGlobals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @title IModuleGlobals\n * @author Lens Protocol\n *\n * @notice This is the interface for the ModuleGlobals contract, a data providing contract to be queried by modules\n * for the most up-to-date parameters.\n */\ninterface IModuleGlobals {\n    /**\n     * @notice Sets the governance address. This function can only be called by governance.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external;\n\n    /**\n     * @notice Sets the treasury address. This function can only be called by governance.\n     *\n     * @param newTreasury The new treasury address to set.\n     */\n    function setTreasury(address newTreasury) external;\n\n    /**\n     * @notice Sets the treasury fee. This function can only be called by governance.\n     *\n     * @param newTreasuryFee The new treasury fee to set.\n     */\n    function setTreasuryFee(uint16 newTreasuryFee) external;\n\n    /**\n     * @notice Adds or removes a currency from the whitelist. This function can only be called by governance.\n     *\n     * @param currency The currency to add or remove from the whitelist.\n     * @param toWhitelist Whether to add or remove the currency from the whitelist.\n     */\n    function whitelistCurrency(address currency, bool toWhitelist) external;\n\n    /// ************************\n    /// *****VIEW FUNCTIONS*****\n    /// ************************\n\n    /**\n     * @notice Returns whether a currency is whitelisted.\n     *\n     * @param currency The currency to query the whitelist for.\n     *\n     * @return bool True if the queried currency is whitelisted, false otherwise.\n     */\n    function isCurrencyWhitelisted(address currency) external view returns (bool);\n\n    /**\n     * @notice Returns the governance address.\n     *\n     * @return address The governance address.\n     */\n    function getGovernance() external view returns (address);\n\n    /**\n     * @notice Returns the treasury address.\n     *\n     * @return address The treasury address.\n     */\n    function getTreasury() external view returns (address);\n\n    /**\n     * @notice Returns the treasury fee.\n     *\n     * @return uint16 The treasury fee.\n     */\n    function getTreasuryFee() external view returns (uint16);\n\n    /**\n     * @notice Returns the treasury address and treasury fee in a single call.\n     *\n     * @return tuplee First, the treasury address, second, the treasury fee.\n     */\n    function getTreasuryData() external view returns (address, uint16);\n}\n"
    },
    "contracts/interfaces/IReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @title IReferenceModule\n * @author Lens Protocol\n *\n * @notice This is the standard interface for all Lens-compatible ReferenceModules.\n */\ninterface IReferenceModule {\n    /**\n     * @notice Initializes data for a given publication being published. This can only be called by the hub.\n     * @param profileId The token ID of the profile publishing the publication.\n     * @param pubId The associated publication's LensHub publication ID.\n     * @param data Arbitrary data passed from the user to be decoded.\n     *\n     * @return bytes An abi encoded byte array encapsulating the execution's state changes. This will be emitted by the\n     * hub alongside the collect module's address and should be consumed by front ends.\n     */\n    function initializeReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external returns (bytes memory);\n\n    /**\n     * @notice Processes a comment action referencing a given publication. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile associated with the publication being published.\n     * @param profileIdPointed The profile ID of the profile associated the publication being referenced.\n     * @param pubIdPointed The publication ID of the publication being referenced.\n     * @param data Arbitrary data __passed from the commenter!__ to be decoded.\n     */\n    function processComment(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Processes a mirror action referencing a given publication. This can only be called by the hub.\n     *\n     * @param profileId The token ID of the profile associated with the publication being published.\n     * @param profileIdPointed The profile ID of the profile associated the publication being referenced.\n     * @param pubIdPointed The publication ID of the publication being referenced.\n     * @param data Arbitrary data __passed from the mirrorer!__ to be decoded.\n     */\n    function processMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nlibrary Constants {\n    string internal constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string internal constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n    string internal constant COLLECT_NFT_NAME_INFIX = '-Collect-';\n    string internal constant COLLECT_NFT_SYMBOL_INFIX = '-Cl-';\n    uint8 internal constant MAX_HANDLE_LENGTH = 31;\n    uint16 internal constant MAX_PROFILE_IMAGE_URI_LENGTH = 6000;\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @title DataTypes\n * @author Lens Protocol\n *\n * @notice A standard library of data types used throughout the Lens Protocol.\n */\nlibrary DataTypes {\n    /**\n     * @notice An enum containing the different states the protocol can be in, limiting certain actions.\n     *\n     * @param Unpaused The fully unpaused state.\n     * @param PublishingPaused The state where only publication creation functions are paused.\n     * @param Paused The fully paused state.\n     */\n    enum ProtocolState {\n        Unpaused,\n        PublishingPaused,\n        Paused\n    }\n\n    /**\n     * @notice An enum specifically used in a helper function to easily retrieve the publication type for integrations.\n     *\n     * @param Post A standard post, having a URI, a collect module but no pointer to another publication.\n     * @param Comment A comment, having a URI, a collect module and a pointer to another publication.\n     * @param Mirror A mirror, having a pointer to another publication, but no URI or collect module.\n     * @param Nonexistent An indicator showing the queried publication does not exist.\n     */\n    enum PubType {\n        Post,\n        Comment,\n        Mirror,\n        Nonexistent\n    }\n\n    /**\n     * @notice A struct containing the necessary information to reconstruct an EIP-712 typed data signature.\n     *\n     * @param v The signature's recovery parameter.\n     * @param r The signature's r parameter.\n     * @param s The signature's s parameter\n     * @param deadline The signature's deadline\n     */\n    struct EIP712Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice A struct containing profile data.\n     *\n     * @param pubCount The number of publications made to this profile.\n     * @param followModule The address of the current follow module in use by this profile, can be empty.\n     * @param followNFT The address of the followNFT associated with this profile, can be empty..\n     * @param handle The profile's associated handle.\n     * @param imageURI The URI to be used for the profile's image.\n     * @param followNFTURI The URI to be used for the follow NFT.\n     */\n    struct ProfileStruct {\n        uint256 pubCount;\n        address followModule;\n        address followNFT;\n        string handle;\n        string imageURI;\n        string followNFTURI;\n    }\n\n    /**\n     * @notice A struct containing data associated with each new publication.\n     *\n     * @param profileIdPointed The profile token ID this publication points to, for mirrors and comments.\n     * @param pubIdPointed The publication ID this publication points to, for mirrors and comments.\n     * @param contentURI The URI associated with this publication.\n     * @param referenceModule The address of the current reference module in use by this publication, can be empty.\n     * @param collectModule The address of the collect module associated with this publication, this exists for all publication.\n     * @param collectNFT The address of the collectNFT associated with this publication, if any.\n     */\n    struct PublicationStruct {\n        uint256 profileIdPointed;\n        uint256 pubIdPointed;\n        string contentURI;\n        address referenceModule;\n        address collectModule;\n        address collectNFT;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `createProfile()` function.\n     *\n     * @param to The address receiving the profile.\n     * @param handle The handle to set for the profile, must be unique and non-empty.\n     * @param imageURI The URI to set for the profile image.\n     * @param followModule The follow module to use, can be the zero address.\n     * @param followModuleInitData The follow module initialization data, if any.\n     * @param followNFTURI The URI to use for the follow NFT.\n     */\n    struct CreateProfileData {\n        address to;\n        string handle;\n        string imageURI;\n        address followModule;\n        bytes followModuleInitData;\n        string followNFTURI;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `setDefaultProfileWithSig()` function. Parameters are\n     * the same as the regular `setDefaultProfile()` function, with an added EIP712Signature.\n     *\n     * @param wallet The address of the wallet setting the default profile.\n     * @param profileId The token ID of the profile which will be set as default, or zero.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct SetDefaultProfileWithSigData {\n        address wallet;\n        uint256 profileId;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `setFollowModuleWithSig()` function. Parameters are\n     * the same as the regular `setFollowModule()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile to change the followModule for.\n     * @param followModule The followModule to set for the given profile, must be whitelisted.\n     * @param followModuleInitData The data to be passed to the followModule for initialization.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct SetFollowModuleWithSigData {\n        uint256 profileId;\n        address followModule;\n        bytes followModuleInitData;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `setDispatcherWithSig()` function. Parameters are the same\n     * as the regular `setDispatcher()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile to set the dispatcher for.\n     * @param dispatcher The dispatcher address to set for the profile.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct SetDispatcherWithSigData {\n        uint256 profileId;\n        address dispatcher;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `setProfileImageURIWithSig()` function. Parameters are the same\n     * as the regular `setProfileImageURI()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile to set the URI for.\n     * @param imageURI The URI to set for the given profile image.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct SetProfileImageURIWithSigData {\n        uint256 profileId;\n        string imageURI;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `setFollowNFTURIWithSig()` function. Parameters are the same\n     * as the regular `setFollowNFTURI()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile for which to set the followNFT URI.\n     * @param followNFTURI The follow NFT URI to set.\n     * @param sig The EIP712Signature struct containing the followNFT's associated profile owner's signature.\n     */\n    struct SetFollowNFTURIWithSigData {\n        uint256 profileId;\n        string followNFTURI;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `post()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param collectModule The collect module to set for this new publication.\n     * @param collectModuleInitData The data to pass to the collect module's initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct PostData {\n        uint256 profileId;\n        string contentURI;\n        address collectModule;\n        bytes collectModuleInitData;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `postWithSig()` function. Parameters are the same as\n     * the regular `post()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param collectModule The collectModule to set for this new publication.\n     * @param collectModuleInitData The data to pass to the collectModule's initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct PostWithSigData {\n        uint256 profileId;\n        string contentURI;\n        address collectModule;\n        bytes collectModuleInitData;\n        address referenceModule;\n        bytes referenceModuleInitData;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `comment()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param profileIdPointed The profile token ID to point the comment to.\n     * @param pubIdPointed The publication ID to point the comment to.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param collectModule The collect module to set for this new publication.\n     * @param collectModuleInitData The data to pass to the collect module's initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct CommentData {\n        uint256 profileId;\n        string contentURI;\n        uint256 profileIdPointed;\n        uint256 pubIdPointed;\n        bytes referenceModuleData;\n        address collectModule;\n        bytes collectModuleInitData;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `commentWithSig()` function. Parameters are the same as\n     * the regular `comment()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param contentURI The URI to set for this new publication.\n     * @param profileIdPointed The profile token ID to point the comment to.\n     * @param pubIdPointed The publication ID to point the comment to.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param collectModule The collectModule to set for this new publication.\n     * @param collectModuleInitData The data to pass to the collectModule's initialization.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct CommentWithSigData {\n        uint256 profileId;\n        string contentURI;\n        uint256 profileIdPointed;\n        uint256 pubIdPointed;\n        bytes referenceModuleData;\n        address collectModule;\n        bytes collectModuleInitData;\n        address referenceModule;\n        bytes referenceModuleInitData;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `mirror()` function.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param profileIdPointed The profile token ID to point the mirror to.\n     * @param pubIdPointed The publication ID to point the mirror to.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     */\n    struct MirrorData {\n        uint256 profileId;\n        uint256 profileIdPointed;\n        uint256 pubIdPointed;\n        bytes referenceModuleData;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `mirrorWithSig()` function. Parameters are the same as\n     * the regular `mirror()` function, with an added EIP712Signature.\n     *\n     * @param profileId The token ID of the profile to publish to.\n     * @param profileIdPointed The profile token ID to point the mirror to.\n     * @param pubIdPointed The publication ID to point the mirror to.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\n     */\n    struct MirrorWithSigData {\n        uint256 profileId;\n        uint256 profileIdPointed;\n        uint256 pubIdPointed;\n        bytes referenceModuleData;\n        address referenceModule;\n        bytes referenceModuleInitData;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `followWithSig()` function. Parameters are the same\n     * as the regular `follow()` function, with the follower's (signer) address and an EIP712Signature added.\n     *\n     * @param follower The follower which is the message signer.\n     * @param profileIds The array of token IDs of the profiles to follow.\n     * @param datas The array of arbitrary data to pass to the followModules if needed.\n     * @param sig The EIP712Signature struct containing the follower's signature.\n     */\n    struct FollowWithSigData {\n        address follower;\n        uint256[] profileIds;\n        bytes[] datas;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `collectWithSig()` function. Parameters are the same as\n     * the regular `collect()` function, with the collector's (signer) address and an EIP712Signature added.\n     *\n     * @param collector The collector which is the message signer.\n     * @param profileId The token ID of the profile that published the publication to collect.\n     * @param pubId The publication to collect's publication ID.\n     * @param data The arbitrary data to pass to the collectModule if needed.\n     * @param sig The EIP712Signature struct containing the collector's signature.\n     */\n    struct CollectWithSigData {\n        address collector;\n        uint256 profileId;\n        uint256 pubId;\n        bytes data;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `setProfileMetadataWithSig()` function.\n     *\n     * @param profileId The profile ID for which to set the metadata.\n     * @param metadata The metadata string to set for the profile and user.\n     * @param sig The EIP712Signature struct containing the user's signature.\n     */\n    struct SetProfileMetadataWithSigData {\n        uint256 profileId;\n        string metadata;\n        EIP712Signature sig;\n    }\n\n    /**\n     * @notice A struct containing the parameters required for the `toggleFollowWithSig()` function.\n     *\n     * @param follower The follower which is the message signer.\n     * @param profileIds The token ID array of the profiles.\n     * @param enables The array of booleans to enable/disable follows.\n     * @param sig The EIP712Signature struct containing the follower's signature.\n     */\n    struct ToggleFollowWithSigData {\n        address follower;\n        uint256[] profileIds;\n        bool[] enables;\n        EIP712Signature sig;\n    }\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nlibrary Errors {\n    error CannotInitImplementation();\n    error Initialized();\n    error SignatureExpired();\n    error ZeroSpender();\n    error SignatureInvalid();\n    error NotOwnerOrApproved();\n    error NotHub();\n    error TokenDoesNotExist();\n    error NotGovernance();\n    error NotGovernanceOrEmergencyAdmin();\n    error EmergencyAdminCannotUnpause();\n    error CallerNotWhitelistedModule();\n    error CollectModuleNotWhitelisted();\n    error FollowModuleNotWhitelisted();\n    error ReferenceModuleNotWhitelisted();\n    error ProfileCreatorNotWhitelisted();\n    error NotProfileOwner();\n    error NotProfileOwnerOrDispatcher();\n    error NotDispatcher();\n    error PublicationDoesNotExist();\n    error HandleTaken();\n    error HandleLengthInvalid();\n    error HandleContainsInvalidCharacters();\n    error HandleFirstCharInvalid();\n    error ProfileImageURILengthInvalid();\n    error CallerNotFollowNFT();\n    error CallerNotCollectNFT();\n    error BlockNumberInvalid();\n    error ArrayMismatch();\n    error CannotCommentOnSelf();\n    error NotWhitelisted();\n    error InvalidParameter();\n\n    // Module Errors\n    error InitParamsInvalid();\n    error CollectExpired();\n    error FollowInvalid();\n    error ModuleDataMismatch();\n    error FollowNotApproved();\n    error MintLimitExceeded();\n    error CollectNotAllowed();\n\n    // MultiState Errors\n    error Paused();\n    error PublishingPaused();\n}\n"
    },
    "contracts/libraries/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {DataTypes} from './DataTypes.sol';\n\nlibrary Events {\n    /**\n     * @dev Emitted when the NFT contract's name and symbol are set at initialization.\n     *\n     * @param name The NFT name set.\n     * @param symbol The NFT symbol set.\n     * @param timestamp The current block timestamp.\n     */\n    event BaseInitialized(string name, string symbol, uint256 timestamp);\n\n    /**\n     * @dev Emitted when the hub state is set.\n     *\n     * @param caller The caller who set the state.\n     * @param prevState The previous protocol state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\n     * @param newState The newly set state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\n     * @param timestamp The current block timestamp.\n     */\n    event StateSet(\n        address indexed caller,\n        DataTypes.ProtocolState indexed prevState,\n        DataTypes.ProtocolState indexed newState,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when the governance address is changed. We emit the caller even though it should be the previous\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\n     *\n     * @param caller The caller who set the governance address.\n     * @param prevGovernance The previous governance address.\n     * @param newGovernance The new governance address set.\n     * @param timestamp The current block timestamp.\n     */\n    event GovernanceSet(\n        address indexed caller,\n        address indexed prevGovernance,\n        address indexed newGovernance,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when the emergency admin is changed. We emit the caller even though it should be the previous\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\n     *\n     * @param caller The caller who set the emergency admin address.\n     * @param oldEmergencyAdmin The previous emergency admin address.\n     * @param newEmergencyAdmin The new emergency admin address set.\n     * @param timestamp The current block timestamp.\n     */\n    event EmergencyAdminSet(\n        address indexed caller,\n        address indexed oldEmergencyAdmin,\n        address indexed newEmergencyAdmin,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a profile creator is added to or removed from the whitelist.\n     *\n     * @param profileCreator The address of the profile creator.\n     * @param whitelisted Whether or not the profile creator is being added to the whitelist.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileCreatorWhitelisted(\n        address indexed profileCreator,\n        bool indexed whitelisted,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a follow module is added to or removed from the whitelist.\n     *\n     * @param followModule The address of the follow module.\n     * @param whitelisted Whether or not the follow module is being added to the whitelist.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowModuleWhitelisted(\n        address indexed followModule,\n        bool indexed whitelisted,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a reference module is added to or removed from the whitelist.\n     *\n     * @param referenceModule The address of the reference module.\n     * @param whitelisted Whether or not the reference module is being added to the whitelist.\n     * @param timestamp The current block timestamp.\n     */\n    event ReferenceModuleWhitelisted(\n        address indexed referenceModule,\n        bool indexed whitelisted,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a collect module is added to or removed from the whitelist.\n     *\n     * @param collectModule The address of the collect module.\n     * @param whitelisted Whether or not the collect module is being added to the whitelist.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectModuleWhitelisted(\n        address indexed collectModule,\n        bool indexed whitelisted,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a profile is created.\n     *\n     * @param profileId The newly created profile's token ID.\n     * @param creator The profile creator, who created the token with the given profile ID.\n     * @param to The address receiving the profile with the given profile ID.\n     * @param handle The handle set for the profile.\n     * @param imageURI The image uri set for the profile.\n     * @param followModule The profile's newly set follow module. This CAN be the zero address.\n     * @param followModuleReturnData The data returned from the follow module's initialization. This is abi encoded\n     * and totally depends on the follow module chosen.\n     * @param followNFTURI The URI set for the profile's follow NFT.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileCreated(\n        uint256 indexed profileId,\n        address indexed creator,\n        address indexed to,\n        string handle,\n        string imageURI,\n        address followModule,\n        bytes followModuleReturnData,\n        string followNFTURI,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a a default profile is set for a wallet as its main identity\n     *\n     * @param wallet The wallet which set or unset its default profile.\n     * @param profileId The token ID of the profile being set as default, or zero.\n     * @param timestamp The current block timestamp.\n     */\n    event DefaultProfileSet(address indexed wallet, uint256 indexed profileId, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a dispatcher is set for a specific profile.\n     *\n     * @param profileId The token ID of the profile for which the dispatcher is set.\n     * @param dispatcher The dispatcher set for the given profile.\n     * @param timestamp The current block timestamp.\n     */\n    event DispatcherSet(uint256 indexed profileId, address indexed dispatcher, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a profile's URI is set.\n     *\n     * @param profileId The token ID of the profile for which the URI is set.\n     * @param imageURI The URI set for the given profile.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileImageURISet(uint256 indexed profileId, string imageURI, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a follow NFT's URI is set.\n     *\n     * @param profileId The token ID of the profile for which the followNFT URI is set.\n     * @param followNFTURI The follow NFT URI set.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowNFTURISet(uint256 indexed profileId, string followNFTURI, uint256 timestamp);\n\n    /**\n     * @dev Emitted when a profile's follow module is set.\n     *\n     * @param profileId The profile's token ID.\n     * @param followModule The profile's newly set follow module. This CAN be the zero address.\n     * @param followModuleReturnData The data returned from the follow module's initialization. This is abi encoded\n     * and totally depends on the follow module chosen.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowModuleSet(\n        uint256 indexed profileId,\n        address followModule,\n        bytes followModuleReturnData,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a \"post\" is published.\n     *\n     * @param profileId The profile's token ID.\n     * @param pubId The new publication's ID.\n     * @param contentURI The URI mapped to this new publication.\n     * @param collectModule The collect module mapped to this new publication. This CANNOT be the zero address.\n     * @param collectModuleReturnData The data returned from the collect module's initialization for this given\n     * publication. This is abi encoded and totally depends on the collect module chosen.\n     * @param referenceModule The reference module set for this publication.\n     * @param referenceModuleReturnData The data returned from the reference module at initialization. This is abi\n     * encoded and totally depends on the reference module chosen.\n     * @param timestamp The current block timestamp.\n     */\n    event PostCreated(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        string contentURI,\n        address collectModule,\n        bytes collectModuleReturnData,\n        address referenceModule,\n        bytes referenceModuleReturnData,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a \"comment\" is published.\n     *\n     * @param profileId The profile's token ID.\n     * @param pubId The new publication's ID.\n     * @param contentURI The URI mapped to this new publication.\n     * @param profileIdPointed The profile token ID that this comment points to.\n     * @param pubIdPointed The publication ID that this comment points to.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param collectModule The collect module mapped to this new publication. This CANNOT be the zero address.\n     * @param collectModuleReturnData The data returned from the collect module's initialization for this given\n     * publication. This is abi encoded and totally depends on the collect module chosen.\n     * @param referenceModule The reference module set for this publication.\n     * @param referenceModuleReturnData The data returned from the reference module at initialization. This is abi\n     * encoded and totally depends on the reference module chosen.\n     * @param timestamp The current block timestamp.\n     */\n    event CommentCreated(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        string contentURI,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes referenceModuleData,\n        address collectModule,\n        bytes collectModuleReturnData,\n        address referenceModule,\n        bytes referenceModuleReturnData,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a \"mirror\" is published.\n     *\n     * @param profileId The profile's token ID.\n     * @param pubId The new publication's ID.\n     * @param profileIdPointed The profile token ID that this mirror points to.\n     * @param pubIdPointed The publication ID that this mirror points to.\n     * @param referenceModuleData The data passed to the reference module.\n     * @param referenceModule The reference module set for this publication.\n     * @param referenceModuleReturnData The data returned from the reference module at initialization. This is abi\n     * encoded and totally depends on the reference module chosen.\n     * @param timestamp The current block timestamp.\n     */\n    event MirrorCreated(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes referenceModuleData,\n        address referenceModule,\n        bytes referenceModuleReturnData,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a followNFT clone is deployed using a lazy deployment pattern.\n     *\n     * @param profileId The token ID of the profile to which this followNFT is associated.\n     * @param followNFT The address of the newly deployed followNFT clone.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowNFTDeployed(\n        uint256 indexed profileId,\n        address indexed followNFT,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a collectNFT clone is deployed using a lazy deployment pattern.\n     *\n     * @param profileId The publisher's profile token ID.\n     * @param pubId The publication associated with the newly deployed collectNFT clone's ID.\n     * @param collectNFT The address of the newly deployed collectNFT clone.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectNFTDeployed(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        address indexed collectNFT,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful collect action.\n     *\n     * @param collector The address collecting the publication.\n     * @param profileId The token ID of the profile that the collect was initiated towards, useful to differentiate mirrors.\n     * @param pubId The publication ID that the collect was initiated towards, useful to differentiate mirrors.\n     * @param rootProfileId The profile token ID of the profile whose publication is being collected.\n     * @param rootPubId The publication ID of the publication being collected.\n     * @param collectModuleData The data passed to the collect module.\n     * @param timestamp The current block timestamp.\n     */\n    event Collected(\n        address indexed collector,\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        uint256 rootProfileId,\n        uint256 rootPubId,\n        bytes collectModuleData,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted upon a successful follow action.\n     *\n     * @param follower The address following the given profiles.\n     * @param profileIds The token ID array of the profiles being followed.\n     * @param followModuleDatas The array of data parameters passed to each follow module.\n     * @param timestamp The current block timestamp.\n     */\n    event Followed(\n        address indexed follower,\n        uint256[] profileIds,\n        bytes[] followModuleDatas,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted via callback when a followNFT is transferred.\n     *\n     * @param profileId The token ID of the profile associated with the followNFT being transferred.\n     * @param followNFTId The followNFT being transferred's token ID.\n     * @param from The address the followNFT is being transferred from.\n     * @param to The address the followNFT is being transferred to.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowNFTTransferred(\n        uint256 indexed profileId,\n        uint256 indexed followNFTId,\n        address from,\n        address to,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted via callback when a collectNFT is transferred.\n     *\n     * @param profileId The token ID of the profile associated with the collectNFT being transferred.\n     * @param pubId The publication ID associated with the collectNFT being transferred.\n     * @param collectNFTId The collectNFT being transferred's token ID.\n     * @param from The address the collectNFT is being transferred from.\n     * @param to The address the collectNFT is being transferred to.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectNFTTransferred(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        uint256 indexed collectNFTId,\n        address from,\n        address to,\n        uint256 timestamp\n    );\n\n    // Collect/Follow NFT-Specific\n\n    /**\n     * @dev Emitted when a newly deployed follow NFT is initialized.\n     *\n     * @param profileId The token ID of the profile connected to this follow NFT.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowNFTInitialized(uint256 indexed profileId, uint256 timestamp);\n\n    /**\n     * @dev Emitted when delegation power in a FollowNFT is changed.\n     *\n     * @param delegate The delegate whose power has been changed.\n     * @param newPower The new governance power mapped to the delegate.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowNFTDelegatedPowerChanged(\n        address indexed delegate,\n        uint256 indexed newPower,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when a newly deployed collect NFT is initialized.\n     *\n     * @param profileId The token ID of the profile connected to the publication mapped to this collect NFT.\n     * @param pubId The publication ID connected to the publication mapped to this collect NFT.\n     * @param timestamp The current block timestamp.\n     */\n    event CollectNFTInitialized(\n        uint256 indexed profileId,\n        uint256 indexed pubId,\n        uint256 timestamp\n    );\n\n    // Module-Specific\n\n    /**\n     * @notice Emitted when the ModuleGlobals governance address is set.\n     *\n     * @param prevGovernance The previous governance address.\n     * @param newGovernance The new governance address set.\n     * @param timestamp The current block timestamp.\n     */\n    event ModuleGlobalsGovernanceSet(\n        address indexed prevGovernance,\n        address indexed newGovernance,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when the ModuleGlobals treasury address is set.\n     *\n     * @param prevTreasury The previous treasury address.\n     * @param newTreasury The new treasury address set.\n     * @param timestamp The current block timestamp.\n     */\n    event ModuleGlobalsTreasurySet(\n        address indexed prevTreasury,\n        address indexed newTreasury,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when the ModuleGlobals treasury fee is set.\n     *\n     * @param prevTreasuryFee The previous treasury fee in BPS.\n     * @param newTreasuryFee The new treasury fee in BPS.\n     * @param timestamp The current block timestamp.\n     */\n    event ModuleGlobalsTreasuryFeeSet(\n        uint16 indexed prevTreasuryFee,\n        uint16 indexed newTreasuryFee,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when a currency is added to or removed from the ModuleGlobals whitelist.\n     *\n     * @param currency The currency address.\n     * @param prevWhitelisted Whether or not the currency was previously whitelisted.\n     * @param whitelisted Whether or not the currency is whitelisted.\n     * @param timestamp The current block timestamp.\n     */\n    event ModuleGlobalsCurrencyWhitelisted(\n        address indexed currency,\n        bool indexed prevWhitelisted,\n        bool indexed whitelisted,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when a module inheriting from the `FeeModuleBase` is constructed.\n     *\n     * @param moduleGlobals The ModuleGlobals contract address used.\n     * @param timestamp The current block timestamp.\n     */\n    event FeeModuleBaseConstructed(address indexed moduleGlobals, uint256 timestamp);\n\n    /**\n     * @notice Emitted when a module inheriting from the `ModuleBase` is constructed.\n     *\n     * @param hub The LensHub contract address used.\n     * @param timestamp The current block timestamp.\n     */\n    event ModuleBaseConstructed(address indexed hub, uint256 timestamp);\n\n    /**\n     * @notice Emitted when one or multiple addresses are approved (or disapproved) for following in\n     * the `ApprovalFollowModule`.\n     *\n     * @param owner The profile owner who executed the approval.\n     * @param profileId The profile ID that the follow approvals are granted/revoked for.\n     * @param addresses The addresses that have had the follow approvals grnated/revoked.\n     * @param approved Whether each corresponding address is now approved or disapproved.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowsApproved(\n        address indexed owner,\n        uint256 indexed profileId,\n        address[] addresses,\n        bool[] approved,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when the user wants to enable or disable follows in the `LensPeriphery`.\n     *\n     * @param owner The profile owner who executed the toggle.\n     * @param profileIds The array of token IDs of the profiles each followNFT is associated with.\n     * @param enabled The array of whether each FollowNFT's follow is enabled/disabled.\n     * @param timestamp The current block timestamp.\n     */\n    event FollowsToggled(\n        address indexed owner,\n        uint256[] profileIds,\n        bool[] enabled,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Emitted when the metadata associated with a profile is set in the `LensPeriphery`.\n     *\n     * @param profileId The profile ID the metadata is set for.\n     * @param metadata The metadata set for the profile and user.\n     * @param timestamp The current block timestamp.\n     */\n    event ProfileMetadataSet(uint256 indexed profileId, string metadata, uint256 timestamp);\n}\n"
    },
    "contracts/libraries/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\n\n/**\n * @title Helpers\n * @author Lens Protocol\n *\n * @notice This is a library that only contains a single function that is used in the hub contract as well as in\n * both the publishing logic and interaction logic libraries.\n */\nlibrary Helpers {\n    /**\n     * @notice This helper function just returns the pointed publication if the passed publication is a mirror,\n     * otherwise it returns the passed publication.\n     *\n     * @param profileId The token ID of the profile that published the given publication.\n     * @param pubId The publication ID of the given publication.\n     * @param _pubByIdByProfile A pointer to the storage mapping of publications by pubId by profile ID.\n     *\n     * @return tuple First, the pointed publication's publishing profile ID, second, the pointed publication's ID, and third, the\n     * pointed publication's collect module. If the passed publication is not a mirror, this returns the given publication.\n     */\n    function getPointedIfMirror(\n        uint256 profileId,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            address\n        )\n    {\n        address collectModule = _pubByIdByProfile[profileId][pubId].collectModule;\n        if (collectModule != address(0)) {\n            return (profileId, pubId, collectModule);\n        } else {\n            uint256 pointedTokenId = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n            // We validate existence here as an optimization, so validating in calling contracts is unnecessary\n            if (pointedTokenId == 0) revert Errors.PublicationDoesNotExist();\n\n            uint256 pointedPubId = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n\n            address pointedCollectModule = _pubByIdByProfile[pointedTokenId][pointedPubId]\n                .collectModule;\n\n            return (pointedTokenId, pointedPubId, pointedCollectModule);\n        }\n    }\n}\n"
    },
    "contracts/libraries/InteractionLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {FollowNFTProxy} from '../upgradeability/FollowNFTProxy.sol';\nimport {Helpers} from './Helpers.sol';\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\nimport {Events} from './Events.sol';\nimport {Constants} from './Constants.sol';\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ICollectModule} from '../interfaces/ICollectModule.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\n/**\n * @title InteractionLogic\n * @author Lens Protocol\n *\n * @notice This is the library that contains the logic for follows & collects. \n \n * @dev The functions are external, so they are called from the hub via `delegateCall` under the hood.\n */\nlibrary InteractionLogic {\n    using Strings for uint256;\n\n    /**\n     * @notice Follows the given profiles, executing the necessary logic and module calls before minting the follow\n     * NFT(s) to the follower.\n     *\n     * @param follower The address executing the follow.\n     * @param profileIds The array of profile token IDs to follow.\n     * @param followModuleDatas The array of follow module data parameters to pass to each profile's follow module.\n     * @param _profileById A pointer to the storage mapping of profile structs by profile ID.\n     * @param _profileIdByHandleHash A pointer to the storage mapping of profile IDs by handle hash.\n     *\n     * @return uint256[] An array of integers representing the minted follow NFTs token IDs.\n     */\n    function follow(\n        address follower,\n        uint256[] calldata profileIds,\n        bytes[] calldata followModuleDatas,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(bytes32 => uint256) storage _profileIdByHandleHash\n    ) external returns (uint256[] memory) {\n        if (profileIds.length != followModuleDatas.length) revert Errors.ArrayMismatch();\n        uint256[] memory tokenIds = new uint256[](profileIds.length);\n        for (uint256 i = 0; i < profileIds.length; ) {\n            string memory handle = _profileById[profileIds[i]].handle;\n            if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])\n                revert Errors.TokenDoesNotExist();\n\n            address followModule = _profileById[profileIds[i]].followModule;\n            address followNFT = _profileById[profileIds[i]].followNFT;\n\n            if (followNFT == address(0)) {\n                followNFT = _deployFollowNFT(profileIds[i]);\n                _profileById[profileIds[i]].followNFT = followNFT;\n            }\n\n            tokenIds[i] = IFollowNFT(followNFT).mint(follower);\n\n            if (followModule != address(0)) {\n                IFollowModule(followModule).processFollow(\n                    follower,\n                    profileIds[i],\n                    followModuleDatas[i]\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        emit Events.Followed(follower, profileIds, followModuleDatas, block.timestamp);\n        return tokenIds;\n    }\n\n    /**\n     * @notice Collects the given publication, executing the necessary logic and module call before minting the\n     * collect NFT to the collector.\n     *\n     * @param collector The address executing the collect.\n     * @param profileId The token ID of the publication being collected's parent profile.\n     * @param pubId The publication ID of the publication being collected.\n     * @param collectModuleData The data to pass to the publication's collect module.\n     * @param collectNFTImpl The address of the collect NFT implementation, which has to be passed because it's an immutable in the hub.\n     * @param _pubByIdByProfile A pointer to the storage mapping of publications by pubId by profile ID.\n     * @param _profileById A pointer to the storage mapping of profile structs by profile ID.\n     *\n     * @return uint256 An integer representing the minted token ID.\n     */\n    function collect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata collectModuleData,\n        address collectNFTImpl,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById\n    ) external returns (uint256) {\n        (uint256 rootProfileId, uint256 rootPubId, address rootCollectModule) = Helpers\n            .getPointedIfMirror(profileId, pubId, _pubByIdByProfile);\n\n        uint256 tokenId;\n        // Avoids stack too deep\n        {\n            address collectNFT = _pubByIdByProfile[rootProfileId][rootPubId].collectNFT;\n            if (collectNFT == address(0)) {\n                collectNFT = _deployCollectNFT(\n                    rootProfileId,\n                    rootPubId,\n                    _profileById[rootProfileId].handle,\n                    collectNFTImpl\n                );\n                _pubByIdByProfile[rootProfileId][rootPubId].collectNFT = collectNFT;\n            }\n            tokenId = ICollectNFT(collectNFT).mint(collector);\n        }\n\n        ICollectModule(rootCollectModule).processCollect(\n            profileId,\n            collector,\n            rootProfileId,\n            rootPubId,\n            collectModuleData\n        );\n        _emitCollectedEvent(\n            collector,\n            profileId,\n            pubId,\n            rootProfileId,\n            rootPubId,\n            collectModuleData\n        );\n\n        return tokenId;\n    }\n\n    /**\n     * @notice Deploys the given profile's Follow NFT contract.\n     *\n     * @param profileId The token ID of the profile which Follow NFT should be deployed.\n     *\n     * @return address The address of the deployed Follow NFT contract.\n     */\n    function _deployFollowNFT(uint256 profileId) private returns (address) {\n        bytes memory functionData = abi.encodeWithSelector(\n            IFollowNFT.initialize.selector,\n            profileId\n        );\n        address followNFT = address(new FollowNFTProxy(functionData));\n        emit Events.FollowNFTDeployed(profileId, followNFT, block.timestamp);\n\n        return followNFT;\n    }\n\n    /**\n     * @notice Deploys the given profile's Collect NFT contract.\n     *\n     * @param profileId The token ID of the profile which Collect NFT should be deployed.\n     * @param pubId The publication ID of the publication being collected, which Collect NFT should be deployed.\n     * @param handle The profile's associated handle.\n     * @param collectNFTImpl The address of the Collect NFT implementation that should be used for the deployment.\n     *\n     * @return address The address of the deployed Collect NFT contract.\n     */\n    function _deployCollectNFT(\n        uint256 profileId,\n        uint256 pubId,\n        string memory handle,\n        address collectNFTImpl\n    ) private returns (address) {\n        address collectNFT = Clones.clone(collectNFTImpl);\n\n        bytes4 firstBytes = bytes4(bytes(handle));\n\n        string memory collectNFTName = string(\n            abi.encodePacked(handle, Constants.COLLECT_NFT_NAME_INFIX, pubId.toString())\n        );\n        string memory collectNFTSymbol = string(\n            abi.encodePacked(firstBytes, Constants.COLLECT_NFT_SYMBOL_INFIX, pubId.toString())\n        );\n\n        ICollectNFT(collectNFT).initialize(profileId, pubId, collectNFTName, collectNFTSymbol);\n        emit Events.CollectNFTDeployed(profileId, pubId, collectNFT, block.timestamp);\n\n        return collectNFT;\n    }\n\n    /**\n     * @notice Emits the `Collected` event that signals that a successful collect action has occurred.\n     *\n     * @dev This is done through this function to prevent stack too deep compilation error.\n     *\n     * @param collector The address collecting the publication.\n     * @param profileId The token ID of the profile that the collect was initiated towards, useful to differentiate mirrors.\n     * @param pubId The publication ID that the collect was initiated towards, useful to differentiate mirrors.\n     * @param rootProfileId The profile token ID of the profile whose publication is being collected.\n     * @param rootPubId The publication ID of the publication being collected.\n     * @param data The data passed to the collect module.\n     */\n    function _emitCollectedEvent(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        uint256 rootProfileId,\n        uint256 rootPubId,\n        bytes calldata data\n    ) private {\n        emit Events.Collected(\n            collector,\n            profileId,\n            pubId,\n            rootProfileId,\n            rootPubId,\n            data,\n            block.timestamp\n        );\n    }\n}\n"
    },
    "contracts/libraries/ProfileTokenURILogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Base64.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nlibrary ProfileTokenURILogic {\n    uint8 internal constant DEFAULT_FONT_SIZE = 24;\n    uint8 internal constant MAX_HANDLE_LENGTH_WITH_DEFAULT_FONT_SIZE = 17;\n\n    /**\n     * @notice Generates the token URI for the profile NFT.\n     *\n     * @dev The decoded token URI JSON metadata contains the following fields: name, description, image and attributes.\n     * The image field contains a base64-encoded SVG. Both the JSON metadata and the image are generated fully on-chain.\n     *\n     * @param id The token ID of the profile.\n     * @param followers The number of profile's followers.\n     * @param owner The address which owns the profile.\n     * @param handle The profile's handle.\n     * @param imageURI The profile's picture URI. An empty string if has not been set.\n     *\n     * @return string The profile's token URI as a base64-encoded JSON string.\n     */\n    function getProfileTokenURI(\n        uint256 id,\n        uint256 followers,\n        address owner,\n        string memory handle,\n        string memory imageURI\n    ) external pure returns (string memory) {\n        string memory handleWithAtSymbol = string(abi.encodePacked('@', handle));\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    Base64.encode(\n                        abi.encodePacked(\n                            '{\"name\":\"',\n                            handleWithAtSymbol,\n                            '\",\"description\":\"',\n                            handleWithAtSymbol,\n                            ' - Lens profile\",\"image\":\"data:image/svg+xml;base64,',\n                            _getSVGImageBase64Encoded(handleWithAtSymbol, imageURI),\n                            '\",\"attributes\":[{\"trait_type\":\"id\",\"value\":\"#',\n                            Strings.toString(id),\n                            '\"},{\"trait_type\":\"followers\",\"value\":\"',\n                            Strings.toString(followers),\n                            '\"},{\"trait_type\":\"owner\",\"value\":\"',\n                            Strings.toHexString(uint160(owner)),\n                            '\"},{\"trait_type\":\"handle\",\"value\":\"',\n                            handleWithAtSymbol,\n                            '\"}]}'\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Generates the token image.\n     *\n     * @dev If the image URI was set and meets URI format conditions, it will be embedded in the token image.\n     * Otherwise, a default picture will be used. Handle font size is a function of handle length.\n     *\n     * @param handleWithAtSymbol The profile's handle beginning with \"@\" symbol.\n     * @param imageURI The profile's picture URI. An empty string if has not been set.\n     *\n     * @return string The profile token image as a base64-encoded SVG.\n     */\n    function _getSVGImageBase64Encoded(string memory handleWithAtSymbol, string memory imageURI)\n        internal\n        pure\n        returns (string memory)\n    {\n        return\n            Base64.encode(\n                abi.encodePacked(\n                    '<svg width=\"450\" height=\"450\" viewBox=\"0 0 450 450\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><defs><style>@font-face{font-family:\"Space Grotesk\";src:url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABdkAAwAAAAAL9QAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAABHUE9TAAABHAAAAoAAAAk8PvUwqU9TLzIAAAOcAAAATQAAAGATnCUlY21hcAAAA+wAAACHAAABctDw6HNnYXNwAAAEdAAAAAgAAAAIAAAAEGdseWYAAAR8AAAO/QAAHeShD1G1aGVhZAAAE3wAAAA2AAAANhn88zloaGVhAAATtAAAAB0AAAAkA80DM2htdHgAABPUAAAA9QAAAVCuDg9sbG9jYQAAFMwAAACqAAAAqkExOixtYXhwAAAVeAAAABYAAAAgAFkAVW5hbWUAABWQAAABvQAAA3L4aVZRcG9zdAAAF1AAAAAUAAAAIP+fAIZ4nM1VQU8TQRT+urvdra0tUKmIIonRlNiqqchJE+PB6MWDJv4BD3rRcDCa+AM8+KuMF+XgVeIBDcZaNREQChYR8PnN7LQd0t21jQnxTd6bmTfvzft2duY9pABkcQrTcK5eu3EbhQd3Hs2iAI96iECtp+7ffTiLjBpp9uBw5mSe0tPx3ynb4E1wDscxCYtkyfRbsiItJJAsyaLum7JuNB/IO7Kpx8m+jc7op+mb1up2ou9a0ur+kOxo+cPSbCbaL8sv3a+Qv3e0LfkmL/qOqXx39eixlqsD4F1u+5p5I942YZfuX2vIRqTFnOlXZUH3W52V15bVpx4/kbfy3tyc+fDb1A3qnqpsy0avXyzSz/bfkXX52K/nv5F8bWOWZ+pu843M7U/k/5/s1zKgZzO8be1cMZDvF5WV/mIT+3bVu0n0fCXPe3S78pL3uRXiDfNgNHJm6uhdf4c5Lswyg5GdR2MsIrOr1FV+0IitqKoadPOMrPFdz/eNhNWhmyX4Dxf69YzcLTbbqbxokYM8OeDoAEbg4xBKGMIYxlHEMUxwNokpziuo4gTOsp1EDTOsppfYTuMyWwXX2aq4xXaGtdPBTbhIc6SaT04zQkCZZh31dHVVnOGawygHGcdBjrX1MI4y8ijRHGFMhSVLXIp8NhBre+wbjaKCloGWQ1oOW184EnEIRYMypWee2cMhapdoVO13jKWvsYO4ckQKYp6gHCe+UeIbI+KihdLVe+UNKlfP3T2RXQulTcM9GoU8xf09jeIJ7uEKLvLky+ZMA8Yt89/UuGeWmTRHzpN55lLXcpGoAubyEitghVwl18jnydPkC+QZsrfHv8SK66BM7ymp/wEGBf5JeJxjYGESYpzAwMrAwNTFFMHAwOANoRnjGIwYlRmQwEIGhv8CSHw3byBxgEGBoYr5xr87DAwsdYwqCgyMk0FyjM+Y9gApBQZmABshDO4AAAB4nGNgYGBmgGAZBkYGEMgB8hjBfBaGACAtAIQgeQUGXQY9BksGB4Z4hqr//+EiBmCRxP///z/8/+v/j/9v/r/8f/L/QqhpKICRDVMMQw0yR12NQUZWTl5BUUlZRRUipIlfuwYDEzMLKxs7BycXNw8vH7+AoJCwiKiYuISklDRhy+kAAIBoGQsAAAEAAf//AA94nL1Za3Ab13XeuyAJkACWhEAAIvEggSUAgniQwGIBgiAWDwIkQQAEQYCiSNF8yZL1lsC0lcZKUo07cTNT006jiaO47jTx2E2naexJ46aT1HEytd0objVuk0maPpSmnfaHGk9bU0nsJtay5+4uSYAiXStyKw4WmN2997y+851zrogGYmHzEzK5zEa0El2EmygSRKPNwWqCIcYa0Os07U203RoIwQ0HbbU1wQ19GJ7DY3ja3uSEX3HEIRYe25rMiGaDHGICFmRG7RRqRRT8QPq5lZU5FMZX/gYa4CIRjv/r+NDQ3+jNZj18wgZrq6132O1JxL2TA96819JvbFMrLyytkm2rS0urd/5rdSmZTpJNqZGR1J2fJ9OfMun0JpNeZ1p3WFxt8laadro8voNGX5K2xVwN9kC3Si4/oOkh6v+RRGBzg3SgtwkH4ScIg82HsLpRSXu5kyPBKtA8inS0zRFDNEU6AyH4BsPb9beYysBAJfhcbDiaUk2ogrOxxRMmb8baq1LaE32js8/0x+JUT9ofSFp7gsORgYOuEdfK4ZuWEXtXo9ZlTJdzSpfL5cN6lEGPLPkSoSd6BH87aR2tYTQMVkDynSBY8mq7Hq3mZ7RUoUipPGNM4iQXP1nJLy3lcysr1JC9RL7E/8jgMsaqk+rJteHRldnm2RXhQhCIiIIsG9hsw5J8CDYVI2SQ+0jahgPUboEbobCBIlFwrJpMVsdGj0YUhUZ7asBf8HoL/myheVI5dJSKrU0qi9VY8JC/rWe4xzMdaY5Me/KDmoFDQdG/WJZ/x65aaWCdhmbpuwyzxU9x3MkEM+ZRUcUC1V4Jbxk2vAbmVGNGlwF130mX7EO1homyOsCuDqJ7lywzsm5bJLP6cPgQM3GB486NZU4N81XZ8ng8fSDdys78O+IaZlIjh6j4Wk6VX4tHz030FOeGeq1dXB/qT+fz4D8zOPFpsOkAQYTBAgYQL+DDjBgI2peffNLbd/mY5amnCPRs5iO9vrSlmuEXBP0GyX7QzwxZRYTFvNAbGJbBOWVlrQEBXzQobqjzSJQ7FS+U26mcp49/EYUtEPLRIDjpXckvG1Th3HC0p3TnuV7fqOVr+j7j8PljyxXFzNLSjKKyTOCYlyEYB4U4gM7buNJpaI0kplykWlzJQHg2WMxyY3MEIOif9M7O/rkU/wNky6YWjvwMx5OD3f6UfJ6QATsIO8lqcr9cdHbSdGenzUagW7yBZG2dRpvN2GkTsLB5e3OQ+CqsbcFayFkmwGoE07U1W6jTlqK3b0Da5vqohSxgs8g721uJtjSBLSrJljCjRjQkDJjwo3P8W8hw9haF9X/w2//xi+99j9iyn3gG1sjENeUivHAnvf1MRqENwi480zFSXETobLuo5ke5QFGJochYG6XJcP4JdzHChDLCBeyOdXoCPT2B3lyQ/xOU9kdGU/zfb30TO7EAeboaefWxKFBthdx2KNCtMh3xzdcEQsQ6xpIGOHo31u/mCnaiGo9XJ8Tr5AMPTBYWFymuWlDn1zhuLa8uVLmxo5XmylHhIvLRIJmF/YW8NexoKeyOIeqkNdo6IaC0diYfPxnfyt0vSPC8Tn4JUjV2oYipyNin53+MiF15O0j6t2Q1aqQckAwSE0RWb8+/bLEeZEa+0k4Vfr4lC+kw/IEnihdiwIN3inWyBN+jWfRjgtr2vZC6YlDVIc9QnE2Cw4e7LeNRjv++EC9mcwPdBP36RGYOWyB3QlAh+pGPFIELzCmVhC5kIQHG6OCRj6hzCk/SHk7EWFf/pO94pfxQ60RzOhAYCvtcwbL/NFU5ohkIGzx2R1eLXGEb8qQmcmkt67b30FaFvLlrqH98UpCP+eb3yE9jvrHjSowpB1QHrsF1Ccn7vFevFj/7WfNZwteLJjPPP5/hX7ZI2C5svk0eQLcw1jBKhIzTM9ibEvkiip1jAGej88C1bZPNviNJ1Mv/UMAZbwDgifsAo6J3YR85+E3GaOFP9sYLlavU1coLONen0fO8Ab/HAnjehPdat98T3qXh79OrUyXq9G+cpkpTq795Rn0Gr8ujF4WPAX/j9cCMUI9vEWqCiCMnY4DklhsgueXuV19e+iT128vfeHX5SepJ4p23vv71t9555RXRxkHBRvCToZZF64wFnnkcHTQDyaUC2xZ73cAwf6xzdfjmk8jF3xzHVmO+EWyOweUN2FeJ2RqxwNA6pLPqYijMfxdd4a+jBHEcMcrMcf6GKg04HoaczJCvg+5GASmA2JDYPjTtysfExfX1i5fW1y/Nzy8cPnxknlpff/axxx9/7Nn19eyZlS+unD6z/MXV01gHiDmaBt4Cv9s1tJzWMhqEWj9++POfIchH/xv1b3EY9nsfyHZJlQVaMHJb4l09GAkFUceyS6mwN+1YGM8vT6XWxsfPc6GlRIgZsaHfJbK5+XC7hnLFfQ2pQmmaUudPhUPLieb03GC7po0O+TRZQa4XbHaBfvYtFmJ0ksuDPuRGrF1wW6NuWzrqn/jVkdJqcWrOk/OuISVfRf/G/yIQPRrlLlCDp3LaA4XD5bjCFzEe+4IqW/0DlXsmoUythsC/gEHyEMhqwejCG0NYIQt0dquGRmidv4oc1y5dgi8TxW8QTyyjG7wp+8QP0Jf5ua08Jp2wvvduXR2475HTGivEt7bnQr7CBa60kJ+an830Bi0t59Bf8R+jlM6UP3Y0OnyBip7MqJqLlfnJ5txch12DLmc32h2dgyfGlWNnYoSECT/ExYr7yzqe1tFSdJi7eBuTidCG6VFovJrkqpOFs5HpqdL0PHWgkouf4JJr4/lFd54J5N2LVORU9ifFc9HwEscV5iZXLMzg8VHV2IlI9tCEIjDuco0HFBOHpBwmdWB/q4CRUFiCNJZ0TaWBUCyjn/K3VM1EBz1gRf+gzC7zKp2tE/JaRvjAjgTYYScYIlljSZj1kfWlR66zkHvUoPpigcKli0lP3GiM2JNr2YlqsmfQZOLciYvTM0dXD82sHq1MHVkoFhcWKP/csDKYtjeqFT2cVxkpeTyliNLL9SjUjfZ0UDk858+m4op4SrigcmxQEYnFIorBmNh/4pj31vqfZaSY02Idq1deFuDQjpoWhNyFs4Ol6WJ5Tq0t5+InuVR1PFtNxNZy4PoH8hCEAhVejtU4fvyhSOTkxE8mz0dR2pX1K3IzMzmFP+sC/w9tbhB/TjyM+cRQ0/J81Ox0mi0OB+WwwBU+OFZF4ia6iBxCvwJBKqLem9mswHWPkl2bb+D7wHW6AvrOw3CfxBwo+yr5TSKDK9x2dKJINKzJjaTpha5vwXHvqYe3tvJ1q/uHulJfcsn2R2/8yrnXHtF9+KVTD8xYXX2Ugo76ootscCHqHbK1UAUlpRr0T187pTn7zPzSH1Vf/cf41FQcPtdPvLaue+y1E8e+9ojt1z9q72rRuUyJC5kDY+cSHQ7tKP/hVtXsMdP535mu/P7ltoc/XxlDssVKS2VpeVpVwr2rDPM6OSf023o8s+zRczO7GlGhB7+0arl9+3axt4OmO4y4Ja3pxoX2NAg9pdWKe0pSkJGWZOwnYaezv12s201oJRERIlniBehvIb61Le2HpGa2ph2WEfbN22gFnYZK4YSMEvEgZBPaXocTSSeUDnEaBbIK1/x+JT+t76a07nImXfFoW7sM5ZyHYTxehvG6BgZcfQMD6iGfyaqVqRrtdi/Leu32RpVMazX5hliz0QT/jObnzAc7jMaOg2bBz3ZUQivkt7d00v5f6IRK96KUTKgv8Q+Qd0L/T7yD8fRDAU/2ffC07+B4+fLtS5fg13HzrhGybpwkGrAM2VOSDBfuAOx3b2rd61Z9sqCfYnGXjpo3Nvjz2zqQwSkxc6zWfZXYlUWCTsBDWzoNEMPvV6fGvafBvVVD38mYp7zugf9NvZ3p8d0aHQU+kT267bf3GZ1aAqiN0MbUvvLFCVOGfSLxl3kfeYa9zd+hsU9k8FjcvxeV7WUlIqzAL7NoEdd8gzCzIGYrT+U0FA56e+xsb/rGWKkp3uh3uQb6e6z25hyy/ata6e7ridqm1Cl/k6m3z2rr6Wy+zi41d5hYZ2Qc7w9cMQs2dQs88Uvvj0p7CxD6tRTkfvge+zXuPvs1mJOg7i6KPWaYpdmwMGnpnAxLy9/82z88k8/feFz1CFFO/OX32fLHn3sKr0GL6OJWX6rddw1a3FkkcARMu2R53372t/jPoO5rFy/y15CB4t++q5+9n7MY6TwEZpud8xD8lvBMOKd5Fp611J3SiCcz22gD+RhjR6QaVoMyqbWSVJGmn+0S8XKq2Mg1uNyegFrh9UWmD2cyh+fSnkDAA5VCPeRp0lt9tFneGYsOpUeGPzQ88aLTanU4rFanYDPG3RGpRtUg7z5kQkV6T6EkEQYceu6jh+z/AHtILXjhdcCnXOAROR1mNI+pPYmphwhknHuafwbHVgvPXxdnRm3dO4BT8SWSSIBhGeEd5c5kKYwDg9SvzTzxNP8VspEgP/YOnjBzOREzgDIwbBHP5mF8yM/iRJdTSHdE1X7lTeR7Qq0gur3GryjZ7I0Dpk5xDciMgRxYo91nDVqsW4TwOQvU/D3nlC+1tKNOPknq+L8DYR20v7tuTiGJPsDkgzWYlGZw6YBGGrb0u1qYbwEcRkYmm7iGPrc7oFL4vEOAEQEfgYA6HQVAbGFE0YExwjq7rU6ntVvEZB9g8sEaTN6/TFR6b6EkkQRMhu5jrox+YHOl2Ov8s3A+Zd/zhIrZ99DqyhXz2W/2+dbWip/7nKX++KruKAsRRojrIcCeeVc9cyM2LGJKh2sNhf4ssdAQlw06XMyAL/bwd1HgSizdO6ZOxJocvQ6L1RIeVrLxhJIMsD0hi4hrI8QPnyuYd9Wy97k3Ku27OcwEEKfAPZ2PDP6S5yMInzqhImDfJOUNt/PfWBIAIfHkjM6YGQ2x/U5nUBZvOpRMTY/GQ4GG/yS6Quk2FW0x0w5XQyIRD4VDlMpiYrd8tIiKgHETrnD3vDda3H9zJHBR8N7OruL3f3ZFEq7Nn6Fj6IR4Xmd4j/O6b01UKhP4Iw0zLZXxSLZSyUbGK2zYnfaEQp60OyzuiSroGPkX4p7ae9gTVfbZlCT8gKHo+zpXDL2/c8X/AQ2rDncAAAAAAQAAAAIAAGLrDmxfDzz1AAMD6AAAAADbnCKZAAAAANucjWP/8/84A7kDIgAAAAYAAgAAAAAAAHicY2BkYGC+8e8OAwML0//PDCDAyIAKQgCAOwUEAAAAeJxFj78uREEUh79zRqOxCdHYbLKbUCAr4bISd7H0609uQuF2aERWREPJIlGo9R7DC2g8gPcQUWyE34xC8WW+Oed3JnPCIaUZ+DoLfkvhe+Q6c98htxdqfiM/puCTNb5+PnwieRFKZVX3k5Qv4oxd6ayQ2Zvmjuh6lXposOS7zKb7MKt+TdueGfUD1Uuafk7d98nUb/ui/Iw5ecY3K/bKtp/SHXLNPulNAbTsjqmIek0fUAvv/8SMXdCIqL9pD4xH5JNpB/097mF9Zfops8yAsYi8Y1tUIvIZu/9DvhFG9O4l1YjuLevJe8k79sh0RD7/C3VcPPwAAAAAAABwAHYAugDwASYBXAGQAawB6gIOAiwCUAJqAngCsALSAwIDOANuA4gDyAPmBAoEHgQ+BFgEhAScBMYE2gUWBUwFbAWmBewGCgZmBqwGwgbOBtoHSAd6B5wHsgf8CEYIogjUCR4JcAmoCeIKEgpECn4KmAq0CtQK8gsACxQLTguIC84L4AvyDAwMJgxADF4MmAzSDRgNSg14DaYN3A4KDjgOdA6eDsgO8gAAeJxjYGRgYAgBQhYGEGBkQAMAEbwArwAAeJyNUk1q3DAYfXYmKS106KLdpBS0nBTGNqZ0MbMKgckioQlJyN4xiq2MYxlJDuQcuUQu0AuUUuiuh+hB+qxR2k4ooRay3vfz3vfpswG8wjdEWD0X3Csc4SWtFY7xDDrgDbzDTcAjvMFdwJvMvw94C6/xOeAx3uI7WdHoOa2v+BlwhO3oPuAY4+hLwBuYRT8CHuF9/CLgTWzHHwLewiT+FPAYH+ObPd3dGlXVTuRZnomzWorTriil2DfaSbsUx0ZfydKJ3d7V2lgxqZ3r7CxNK+Xq/iIp9XV62WijinZZGOtkm9pBYFqtBHbW5E5k1TeFyZMsy+aLg7kPhtg0BNfrB+e5NFbpVnjmv1gPbdnSqM7ZxKom0aZKjxaH2OM36HALA4UKNRwEcmR+C5zRI3meMqdA6fE+czXzJCyWtI+9fUW79Oxd9Dxr+gwzBCZe1VHBYoaUq2KtIaPnv5CQpXFN7yUaz1Gs1FK58PyhTsuo/d3BlPy/O9h5orsTnhXrNF4tZ7XMrzkWOOD7D3OdN33EfOr+65nntIa+FXNaP8uHmv9b6/G0LDnDVDp6LdUG7YbnMKuK8SPe5fAXpzmxbgAAAHicY2BmAIP/cxiMGDBBCAAq1wIl) format(\"woff\"); font-weight:normal;font-style:normal;} </style><linearGradient id=\"rounded-border-transparency-detail\" x1=\"-137\" y1=\"-236\" x2=\"415\" y2=\"486\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"white\"/><stop offset=\"1\" stop-color=\"white\" stop-opacity=\"0.2\"/></linearGradient><clipPath id=\"outer-rounded-border\"><rect width=\"450\" height=\"450\" rx=\"16\" fill=\"white\"/></clipPath></defs><g><g clip-path=\"url(#outer-rounded-border)\">',\n                    _getSVGProfilePicture(imageURI),\n                    '<rect id=\"bottom-background\" y=\"370\" width=\"450\" height=\"80\" fill=\"#ABFE2C\"/><text id=\"handle\" fill=\"#00501E\" text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"225\" y=\"410\" font-family=\"Space Grotesk\" font-size=\"',\n                    Strings.toString(_handleLengthToFontSize(bytes(handleWithAtSymbol).length)),\n                    '\" font-weight=\"500\" letter-spacing=\"0em\">',\n                    handleWithAtSymbol,\n                    '</text><rect id=\"background-border\" x=\"2.5\" y=\"2.5\" width=\"444\" height=\"444\" rx=\"13\" stroke=\"url(#rounded-border-transparency-detail)\" stroke-width=\"5\"/><path id=\"bottom-logo\" d=\"M70 423a14 14 0 0 1-13-1c2 1 5 1 8-1l-1-2h-1a9 9 0 0 1-8 0 9 9 0 0 1-4-6c3-1 11-2 17-8v-1a8 8 0 0 0 3-6c0-2-1-4-3-5-1-2-3-3-5-3l-5 1-3-4c-2-2-4-2-6-2s-4 0-5 2l-3 4-5-1-6 3-2 5a8 8 0 0 0 2 6l1 1c6 6 14 7 17 8a9 9 0 0 1-4 6 9 9 0 0 1-9 0l-2 2h1c2 2 5 2 8 1a14 14 0 0 1-13 1h-1l-1 2 1 1c3 1 7 2 10 1a16 16 0 0 0 10-6v6h3v-6a16 16 0 0 0 13 6l7-1 1-1-2-2Zm-27-29v-1c1-4 4-6 6-6 3 0 6 2 6 6v5l2-3h1v-1c3-2 6-1 8 0 2 2 3 6 0 8v1c-7 7-17 7-17 7s-9 0-16-7l-1-1c-3-2-2-6 0-8l4-1 4 1 1 1 3 3-1-4Z\" fill=\"#fff\" fill-opacity=\".8\"/></g></g></svg>'\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the fragment of the SVG correponding to the profile picture.\n     *\n     * @dev If the image URI was set and meets URI format conditions, this will return an image tag referencing it.\n     * Otherwise, a group tag that renders the default picture will be returned.\n     *\n     * @param imageURI The profile's picture URI. An empty string if has not been set.\n     *\n     * @return string The fragment of the SVG token's image correspondending to the profile picture.\n     */\n    function _getSVGProfilePicture(string memory imageURI) internal pure returns (string memory) {\n        if (_shouldUseCustomPicture(imageURI)) {\n            return\n                string(\n                    abi.encodePacked(\n                        '<image id=\"custom-picture\" preserveAspectRatio=\"xMidYMid slice\" height=\"450\" width=\"450\" href=\"',\n                        imageURI,\n                        '\"/>'\n                    )\n                );\n        } else {\n            return\n                '<g id=\"default-picture\"><rect id=\"default-picture-background\" x=\"0\" width=\"450\" height=\"450\" fill=\"#ABFE2C\"/><g id=\"default-picture-logo\" transform=\"translate(60,30)\"><style><![CDATA[#ez1M8bKaIyB3_to {animation: ez1M8bKaIyB3_to__to 6000ms linear infinite normal forwards}@keyframes ez1M8bKaIyB3_to__to { 0% { transform: translate3d(0,0,0); transform: translate(161px,137px) rotate(0.05deg);animation-timing-function: cubic-bezier(0.5,0.1,0.7,0.5)} 41% {transform: translate(157px,133px) rotate(0.05deg);animation-timing-function: cubic-bezier(0.2,0.5,0.5,0.9)} 100% {transform: translate(161px,137px) rotate(0.05deg)}} #ez1M8bKaIyB6_to {animation: ez1M8bKaIyB6_to__to 6000ms linear infinite normal forwards}@keyframes ez1M8bKaIyB6_to__to { 0% {transform: translate(160px,136px) rotate(0.05deg);animation-timing-function: cubic-bezier(0.5,0.1,0.7,0.2)} 26% {transform: translate(176px,138px) rotate(0.05deg);animation-timing-function: cubic-bezier(0.2,0.6,0.3,1)} 43% {transform: translate(176px,138px) rotate(0.05deg);animation-timing-function: cubic-bezier(0.2,0.6,0.3,1)} 83% {transform: translate(154px,145px) rotate(0.05deg)} 100% {transform: translate(160px,136px) rotate(0.05deg)}}]]></style><path d=\"m171.3 315.6.1.2-.3-67a113.6 113.6 0 0 0 99.7 58.6 115 115 0 0 0 48.9-10.8l-5.8-10a103.9 103.9 0 0 1-120.5-25.5l4.3 2.9a77 77 0 0 0 77.9 1l-5.7-10-2 1.1a66.4 66.4 0 0 1-96.5-54c19-1.1-30.8-1.1-12 .1A66.4 66.4 0 0 1 60.9 255l-5.7 10 2.4 1.2a76.1 76.1 0 0 0 79.8-5 103.9 103.9 0 0 1-120.6 25.5l-5.7 9.9a115 115 0 0 0 138.5-32.2c3.8-4.8 7.2-10 10-15.3l.6 66.9v-.4h11Z\" fill=\"#00501e\"/><g id=\"ez1M8bKaIyB3_to\" transform=\"translate(162 137.5)\"><g><g transform=\"translate(-165.4 -143.9)\"><path d=\"M185 159.2c-2.4 6.6-9.6 12.2-19.2 12.2-9.3 0-17.3-5.3-19.4-12.4\" fill=\"none\" stroke=\"#00501e\" stroke-width=\"8.3\" stroke-linejoin=\"round\"/><g id=\"ez1M8bKaIyB6_to\" transform=\"translate(160 136.6)\"><g transform=\"translate(0 -1.3)\" fill=\"#00501e\"><path d=\"M124.8 144.7a11.9 11.9 0 1 1-23.8 0 11.9 11.9 0 0 1 23.8 0Z\" transform=\"translate(-154.1 -145)\"/><path d=\"M209.5 144.7a11.9 11.9 0 1 1-23.8 0 11.9 11.9 0 0 1 23.8 0Z\" transform=\"translate(-155 -145)\"/></g></g><path d=\"M92.2 142.8c0-14.6 13.8-26.4 30.8-26.4s30.8 11.8 30.8 26.4M177 142.8c0-14.6 13.8-26.4 30.8-26.4s30.8 11.8 30.8 26.4\" fill=\"none\" stroke=\"#00501e\" stroke-width=\"8.3\" stroke-linejoin=\"round\"/></g></g></g><path d=\"m219.1 70.3-3.2 3.3.1-4.6v-4.7c-1.8-65.4-100.3-65.4-102.1 0l-.1 4.7v4.6l-3.1-3.3-3.4-3.3C59.8 22-10 91.7 35 139.2l3.3 3.4C92.6 196.8 164.9 197 164.9 197s72.3-.2 126.5-54.4l3.3-3.4C339.7 91.7 270 22 222.5 67l-3.4 3.3Z\" fill=\"none\" stroke=\"#00501e\" stroke-width=\"11.2\" stroke-miterlimit=\"10\"/></g></g>';\n        }\n    }\n\n    /**\n     * @notice Maps the handle length to a font size.\n     *\n     * @dev Gives the font size as a function of handle length using the following formula:\n     *\n     *      fontSize(handleLength) = 24                              when handleLength <= 17\n     *      fontSize(handleLength) = 24 - (handleLength - 12) / 2    when handleLength  > 17\n     *\n     * @param handleLength The profile's handle length.\n     * @return uint256 The font size.\n     */\n    function _handleLengthToFontSize(uint256 handleLength) internal pure returns (uint256) {\n        return\n            handleLength <= MAX_HANDLE_LENGTH_WITH_DEFAULT_FONT_SIZE\n                ? DEFAULT_FONT_SIZE\n                : DEFAULT_FONT_SIZE - (handleLength - 12) / 2;\n    }\n\n    /**\n     * @notice Decides if Profile NFT should use user provided custom profile picture or the default one.\n     *\n     * @dev It checks if there is a custom imageURI set and makes sure it does not contain double-quotes to prevent\n     * injection attacks through the generated SVG.\n     *\n     * @param imageURI The imageURI set by the profile owner.\n     *\n     * @return bool A boolean indicating whether custom profile picture should be used or not.\n     */\n    function _shouldUseCustomPicture(string memory imageURI) internal pure returns (bool) {\n        bytes memory imageURIBytes = bytes(imageURI);\n        if (imageURIBytes.length == 0) {\n            return false;\n        }\n        uint256 imageURIBytesLength = imageURIBytes.length;\n        for (uint256 i = 0; i < imageURIBytesLength; ) {\n            if (imageURIBytes[i] == '\"') {\n                // Avoids embedding a user provided imageURI containing double-quotes to prevent injection attacks\n                return false;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/libraries/PublishingLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Helpers} from './Helpers.sol';\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\nimport {Events} from './Events.sol';\nimport {Constants} from './Constants.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ICollectModule} from '../interfaces/ICollectModule.sol';\nimport {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n\n/**\n * @title PublishingLogic\n * @author Lens Protocol\n *\n * @notice This is the library that contains the logic for profile creation & publication.\n *\n * @dev The functions are external, so they are called from the hub via `delegateCall` under the hood. Furthermore,\n * expected events are emitted from this library instead of from the hub to alleviate code size concerns.\n */\nlibrary PublishingLogic {\n    /**\n     * @notice Executes the logic to create a profile with the given parameters to the given address.\n     *\n     * @param vars The CreateProfileData struct containing the following parameters:\n     *      to: The address receiving the profile.\n     *      handle: The handle to set for the profile, must be unique and non-empty.\n     *      imageURI: The URI to set for the profile image.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleInitData: The follow module initialization data, if any\n     *      followNFTURI: The URI to set for the follow NFT.\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\n     * @param _profileIdByHandleHash The storage reference to the mapping of profile IDs by handle hash.\n     * @param _profileById The storage reference to the mapping of profile structs by IDs.\n     * @param _followModuleWhitelisted The storage reference to the mapping of whitelist status by follow module address.\n     */\n    function createProfile(\n        DataTypes.CreateProfileData calldata vars,\n        uint256 profileId,\n        mapping(bytes32 => uint256) storage _profileIdByHandleHash,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) external {\n        _validateHandle(vars.handle);\n\n        if (bytes(vars.imageURI).length > Constants.MAX_PROFILE_IMAGE_URI_LENGTH)\n            revert Errors.ProfileImageURILengthInvalid();\n\n        bytes32 handleHash = keccak256(bytes(vars.handle));\n\n        if (_profileIdByHandleHash[handleHash] != 0) revert Errors.HandleTaken();\n\n        _profileIdByHandleHash[handleHash] = profileId;\n        _profileById[profileId].handle = vars.handle;\n        _profileById[profileId].imageURI = vars.imageURI;\n        _profileById[profileId].followNFTURI = vars.followNFTURI;\n\n        bytes memory followModuleReturnData;\n        if (vars.followModule != address(0)) {\n            _profileById[profileId].followModule = vars.followModule;\n            followModuleReturnData = _initFollowModule(\n                profileId,\n                vars.followModule,\n                vars.followModuleInitData,\n                _followModuleWhitelisted\n            );\n        }\n\n        _emitProfileCreated(profileId, vars, followModuleReturnData);\n    }\n\n    /**\n     * @notice Sets the follow module for a given profile.\n     *\n     * @param profileId The profile ID to set the follow module for.\n     * @param followModule The follow module to set for the given profile, if any.\n     * @param followModuleInitData The data to pass to the follow module for profile initialization.\n     * @param _profile The storage reference to the profile struct associated with the given profile ID.\n     * @param _followModuleWhitelisted The storage reference to the mapping of whitelist status by follow module address.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        DataTypes.ProfileStruct storage _profile,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) external {\n        if (followModule != _profile.followModule) {\n            _profile.followModule = followModule;\n        }\n\n        bytes memory followModuleReturnData;\n        if (followModule != address(0))\n            followModuleReturnData = _initFollowModule(\n                profileId,\n                followModule,\n                followModuleInitData,\n                _followModuleWhitelisted\n            );\n        emit Events.FollowModuleSet(\n            profileId,\n            followModule,\n            followModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Creates a post publication mapped to the given profile.\n     *\n     * @dev To avoid a stack too deep error, reference parameters are passed in memory rather than calldata.\n     *\n     * @param profileId The profile ID to associate this publication to.\n     * @param contentURI The URI to set for this publication.\n     * @param collectModule The collect module to set for this publication.\n     * @param collectModuleInitData The data to pass to the collect module for publication initialization.\n     * @param referenceModule The reference module to set for this publication, if any.\n     * @param referenceModuleInitData The data to pass to the reference module for publication initialization.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _collectModuleWhitelisted The storage reference to the mapping of whitelist status by collect module address.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleInitData,\n        address referenceModule,\n        bytes memory referenceModuleInitData,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        _pubByIdByProfile[profileId][pubId].contentURI = contentURI;\n\n        // Collect module initialization\n        bytes memory collectModuleReturnData = _initPubCollectModule(\n            profileId,\n            pubId,\n            collectModule,\n            collectModuleInitData,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted\n        );\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            profileId,\n            pubId,\n            referenceModule,\n            referenceModuleInitData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        emit Events.PostCreated(\n            profileId,\n            pubId,\n            contentURI,\n            collectModule,\n            collectModuleReturnData,\n            referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Creates a comment publication mapped to the given profile.\n     *\n     * @dev This function is unique in that it requires many variables, so, unlike the other publishing functions,\n     * we need to pass the full CommentData struct in memory to avoid a stack too deep error.\n     *\n     * @param vars The CommentData struct to use to create the comment.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _profileById The storage reference to the mapping of profile structs by IDs.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _collectModuleWhitelisted The storage reference to the mapping of whitelist status by collect module address.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createComment(\n        DataTypes.CommentData memory vars,\n        uint256 pubId,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        // Validate existence of the pointed publication\n        uint256 pubCount = _profileById[vars.profileIdPointed].pubCount;\n        if (pubCount < vars.pubIdPointed || vars.pubIdPointed == 0)\n            revert Errors.PublicationDoesNotExist();\n\n        // Ensure the pointed publication is not the comment being created\n        if (vars.profileId == vars.profileIdPointed && vars.pubIdPointed == pubId)\n            revert Errors.CannotCommentOnSelf();\n\n        _pubByIdByProfile[vars.profileId][pubId].contentURI = vars.contentURI;\n        _pubByIdByProfile[vars.profileId][pubId].profileIdPointed = vars.profileIdPointed;\n        _pubByIdByProfile[vars.profileId][pubId].pubIdPointed = vars.pubIdPointed;\n\n        // Collect Module Initialization\n        bytes memory collectModuleReturnData = _initPubCollectModule(\n            vars.profileId,\n            pubId,\n            vars.collectModule,\n            vars.collectModuleInitData,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted\n        );\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            vars.profileId,\n            pubId,\n            vars.referenceModule,\n            vars.referenceModuleInitData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        // Reference module validation\n        address refModule = _pubByIdByProfile[vars.profileIdPointed][vars.pubIdPointed]\n            .referenceModule;\n        if (refModule != address(0)) {\n            IReferenceModule(refModule).processComment(\n                vars.profileId,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.referenceModuleData\n            );\n        }\n\n        // Prevents a stack too deep error\n        _emitCommentCreated(vars, pubId, collectModuleReturnData, referenceModuleReturnData);\n    }\n\n    /**\n     * @notice Creates a mirror publication mapped to the given profile.\n     *\n     * @param vars The MirrorData struct to use to create the mirror.\n     * @param pubId The publication ID to associate with this publication.\n     * @param _pubByIdByProfile The storage reference to the mapping of publications by publication ID by profile ID.\n     * @param _referenceModuleWhitelisted The storage reference to the mapping of whitelist status by reference module address.\n     */\n    function createMirror(\n        DataTypes.MirrorData memory vars,\n        uint256 pubId,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) external {\n        (uint256 rootProfileIdPointed, uint256 rootPubIdPointed, ) = Helpers.getPointedIfMirror(\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            _pubByIdByProfile\n        );\n\n        _pubByIdByProfile[vars.profileId][pubId].profileIdPointed = rootProfileIdPointed;\n        _pubByIdByProfile[vars.profileId][pubId].pubIdPointed = rootPubIdPointed;\n\n        // Reference module initialization\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\n            vars.profileId,\n            pubId,\n            vars.referenceModule,\n            vars.referenceModuleInitData,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n\n        // Reference module validation\n        address refModule = _pubByIdByProfile[rootProfileIdPointed][rootPubIdPointed]\n            .referenceModule;\n        if (refModule != address(0)) {\n            IReferenceModule(refModule).processMirror(\n                vars.profileId,\n                rootProfileIdPointed,\n                rootPubIdPointed,\n                vars.referenceModuleData\n            );\n        }\n\n        emit Events.MirrorCreated(\n            vars.profileId,\n            pubId,\n            rootProfileIdPointed,\n            rootPubIdPointed,\n            vars.referenceModuleData,\n            vars.referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    function _initPubCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        address collectModule,\n        bytes memory collectModuleInitData,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _collectModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (!_collectModuleWhitelisted[collectModule]) revert Errors.CollectModuleNotWhitelisted();\n        _pubByIdByProfile[profileId][pubId].collectModule = collectModule;\n        return\n            ICollectModule(collectModule).initializePublicationCollectModule(\n                profileId,\n                pubId,\n                collectModuleInitData\n            );\n    }\n\n    function _initPubReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        address referenceModule,\n        bytes memory referenceModuleInitData,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(address => bool) storage _referenceModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (referenceModule == address(0)) return new bytes(0);\n        if (!_referenceModuleWhitelisted[referenceModule])\n            revert Errors.ReferenceModuleNotWhitelisted();\n        _pubByIdByProfile[profileId][pubId].referenceModule = referenceModule;\n        return\n            IReferenceModule(referenceModule).initializeReferenceModule(\n                profileId,\n                pubId,\n                referenceModuleInitData\n            );\n    }\n\n    function _initFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes memory followModuleInitData,\n        mapping(address => bool) storage _followModuleWhitelisted\n    ) private returns (bytes memory) {\n        if (!_followModuleWhitelisted[followModule]) revert Errors.FollowModuleNotWhitelisted();\n        return IFollowModule(followModule).initializeFollowModule(profileId, followModuleInitData);\n    }\n\n    function _emitCommentCreated(\n        DataTypes.CommentData memory vars,\n        uint256 pubId,\n        bytes memory collectModuleReturnData,\n        bytes memory referenceModuleReturnData\n    ) private {\n        emit Events.CommentCreated(\n            vars.profileId,\n            pubId,\n            vars.contentURI,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModuleData,\n            vars.collectModule,\n            collectModuleReturnData,\n            vars.referenceModule,\n            referenceModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    function _emitProfileCreated(\n        uint256 profileId,\n        DataTypes.CreateProfileData calldata vars,\n        bytes memory followModuleReturnData\n    ) internal {\n        emit Events.ProfileCreated(\n            profileId,\n            msg.sender, // Creator is always the msg sender\n            vars.to,\n            vars.handle,\n            vars.imageURI,\n            vars.followModule,\n            followModuleReturnData,\n            vars.followNFTURI,\n            block.timestamp\n        );\n    }\n\n    function _validateHandle(string calldata handle) private pure {\n        bytes memory byteHandle = bytes(handle);\n        if (byteHandle.length == 0 || byteHandle.length > Constants.MAX_HANDLE_LENGTH)\n            revert Errors.HandleLengthInvalid();\n\n        uint256 byteHandleLength = byteHandle.length;\n        for (uint256 i = 0; i < byteHandleLength; ) {\n            if (\n                (byteHandle[i] < '0' ||\n                    byteHandle[i] > 'z' ||\n                    (byteHandle[i] > '9' && byteHandle[i] < 'a')) &&\n                byteHandle[i] != '.' &&\n                byteHandle[i] != '-' &&\n                byteHandle[i] != '_'\n            ) revert Errors.HandleContainsInvalidCharacters();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/misc/LensPeriphery.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IERC721Time} from '../core/base/IERC721Time.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Errors} from '../libraries/Errors.sol';\n\n/**\n * @notice This is a peripheral contract that acts as a source of truth for profile metadata and allows\n * for users to emit an event demonstrating whether or not they explicitly want a follow to be shown.\n *\n * @dev This is useful because it allows clients to filter out follow NFTs that were transferred to\n * a recipient by another user (i.e. Not a mint) and not register them as \"following\" unless\n * the recipient explicitly toggles the follow here.\n */\ncontract LensPeriphery {\n    string public constant NAME = 'LensPeriphery';\n    bytes32 internal constant EIP712_REVISION_HASH = keccak256('1');\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n        );\n    bytes32 internal constant TOGGLE_FOLLOW_WITH_SIG_TYPEHASH =\n        keccak256(\n            'ToggleFollowWithSig(uint256[] profileIds,bool[] enables,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 internal constant SET_PROFILE_METADATA_WITH_SIG_TYPEHASH =\n        keccak256(\n            'SetProfileMetadataURIWithSig(uint256 profileId,string metadata,uint256 nonce,uint256 deadline)'\n        );\n\n    ILensHub public immutable HUB;\n\n    mapping(address => uint256) public sigNonces;\n\n    mapping(uint256 => string) internal _metadataByProfile;\n\n    constructor(ILensHub hub) {\n        HUB = hub;\n    }\n\n    /**\n     * @notice Sets the profile metadata for a given profile.\n     *\n     * @param profileId The profile ID to set the metadata for.\n     * @param metadata The metadata string to set for the profile.\n     */\n    function setProfileMetadataURI(uint256 profileId, string calldata metadata) external {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileMetadataURI(profileId, metadata);\n    }\n\n    /**\n     * @notice Sets the profile metadata for a given profile via signature with the specified parameters.\n     *\n     * @param vars A SetProfileMetadataWithSigData struct containingthe regular parameters and an EIP712Signature struct.\n     */\n    function setProfileMetadataURIWithSig(DataTypes.SetProfileMetadataWithSigData calldata vars)\n        external\n    {\n        unchecked {\n            address owner = IERC721Time(address(HUB)).ownerOf(vars.profileId);\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_METADATA_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.metadata)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                owner,\n                vars.sig\n            );\n        }\n        _setProfileMetadataURI(vars.profileId, vars.metadata);\n    }\n\n    /**\n     * @notice Toggle Follows on the given profiles, emiting toggle event for each FollowNFT.\n     *\n     * NOTE: `profileIds`, `followNFTIds` and `enables` arrays must be of the same length.\n     *\n     * @param profileIds The token ID array of the profiles.\n     * @param enables The array of booleans to enable/disable follows.\n     */\n    function toggleFollow(uint256[] calldata profileIds, bool[] calldata enables) external {\n        _toggleFollow(msg.sender, profileIds, enables);\n    }\n\n    /**\n     * @notice Toggle Follows a given profiles via signature with the specified parameters.\n     *\n     * @param vars A ToggleFollowWithSigData struct containing the regular parameters as well as the signing follower's address\n     * and an EIP712Signature struct.\n     */\n    function toggleFollowWithSig(DataTypes.ToggleFollowWithSigData calldata vars) external {\n        unchecked {\n            _validateRecoveredAddress(\n                _calculateDigest(\n                    keccak256(\n                        abi.encode(\n                            TOGGLE_FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(vars.enables)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                ),\n                vars.follower,\n                vars.sig\n            );\n        }\n\n        _toggleFollow(vars.follower, vars.profileIds, vars.enables);\n    }\n\n    /**\n     * @notice Returns the metadata URI of a profile.\n     *\n     * @param profileId The profile ID to query the metadata URI for.\n     *\n     * @return string The metadata associated with that profile ID, or an empty string if it is not set or the profile does not exist.\n     */\n    function getProfileMetadataURI(uint256 profileId) external view returns (string memory) {\n        return _metadataByProfile[profileId];\n    }\n\n    function _setProfileMetadataURI(uint256 profileId, string calldata metadata) internal {\n        _metadataByProfile[profileId] = metadata;\n        emit Events.ProfileMetadataSet(profileId, metadata, block.timestamp);\n    }\n\n    function _toggleFollow(\n        address follower,\n        uint256[] calldata profileIds,\n        bool[] calldata enables\n    ) internal {\n        if (profileIds.length != enables.length) revert Errors.ArrayMismatch();\n        uint256 profileIdsLength = profileIds.length;\n        for (uint256 i = 0; i < profileIdsLength; ) {\n            address followNFT = HUB.getFollowNFT(profileIds[i]);\n            if (followNFT == address(0)) revert Errors.FollowInvalid();\n            if (!IERC721Time(address(HUB)).exists(profileIds[i])) revert Errors.TokenDoesNotExist();\n            if (IERC721Time(followNFT).balanceOf(follower) == 0) revert Errors.FollowInvalid();\n            unchecked {\n                ++i;\n            }\n        }\n        emit Events.FollowsToggled(follower, profileIds, enables, block.timestamp);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (\n            msg.sender == IERC721Time(address(HUB)).ownerOf(profileId) ||\n            msg.sender == HUB.getDispatcher(profileId)\n        ) {\n            return;\n        }\n        revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    /**\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\n     */\n    function _validateRecoveredAddress(\n        bytes32 digest,\n        address expectedAddress,\n        DataTypes.EIP712Signature memory sig\n    ) internal view {\n        if (sig.deadline < block.timestamp) revert Errors.SignatureExpired();\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n        if (recoveredAddress == address(0) || recoveredAddress != expectedAddress)\n            revert Errors.SignatureInvalid();\n    }\n\n    /**\n     * @dev Calculates EIP712 DOMAIN_SEPARATOR based on the current contract and chain ID.\n     */\n    function _calculateDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    EIP712_REVISION_HASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\n     *\n     * @param hashedMessage The message hash from which the digest should be calculated.\n     *\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\n     */\n    function _calculateDigest(bytes32 hashedMessage) internal view returns (bytes32) {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked('\\x19\\x01', _calculateDomainSeparator(), hashedMessage)\n            );\n        }\n        return digest;\n    }\n}\n"
    },
    "contracts/misc/ProfileCreationProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\n/**\n * @title ProfileCreationProxy\n * @author Lens Protocol\n *\n * @notice This is an ownable proxy contract that enforces \".lens\" handle suffixes at profile creation.\n * Only the owner can create profiles.\n */\ncontract ProfileCreationProxy is Ownable {\n    ILensHub immutable LENS_HUB;\n\n    constructor(address owner, ILensHub hub) {\n        _transferOwnership(owner);\n        LENS_HUB = hub;\n    }\n\n    function proxyCreateProfile(DataTypes.CreateProfileData memory vars) external onlyOwner {\n        uint256 handleLength = bytes(vars.handle).length;\n        if (handleLength < 5) revert Errors.HandleLengthInvalid();\n\n        bytes1 firstByte = bytes(vars.handle)[0];\n        if (firstByte == '-' || firstByte == '_' || firstByte == '.')\n            revert Errors.HandleFirstCharInvalid();\n\n        for (uint256 i = 1; i < handleLength; ) {\n            if (bytes(vars.handle)[i] == '.') revert Errors.HandleContainsInvalidCharacters();\n            unchecked {\n                ++i;\n            }\n        }\n\n        vars.handle = string(abi.encodePacked(vars.handle, '.lens'));\n        LENS_HUB.createProfile(vars);\n    }\n}\n"
    },
    "contracts/misc/UIDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\n\n/**\n * @dev This struct contains both a `ProfileStruct` and a `PublicationStruct`.\n *\n * @param profileStruct A standard profile struct.\n * @param publicationStruct A standard publicationStruct.\n */\nstruct LatestData {\n    DataTypes.ProfileStruct profileStruct;\n    DataTypes.PublicationStruct publicationStruct;\n}\n\n/**\n * @title UIDataProvider\n * @author Lens Protocol\n *\n * @dev This is a helper contract to fetch a profile and its latest publication in a single call.\n */\ncontract UIDataProvider {\n    ILensHub immutable HUB;\n\n    constructor(ILensHub hub) {\n        HUB = hub;\n    }\n\n    /**\n     * @notice Returns the profile struct and latest publication struct associated with the passed\n     * profile ID.\n     *\n     * @param profileId The profile ID to query.\n     *\n     * @return LensData A struct containing the `ProfileStruct` and the `PublicationStruct` queried.\n     */\n    function getLatestDataByProfile(uint256 profileId) external view returns (LatestData memory) {\n        DataTypes.ProfileStruct memory profileStruct = HUB.getProfile(profileId);\n        uint256 pubCount = profileStruct.pubCount;\n        return LatestData(profileStruct, HUB.getPub(profileId, pubCount));\n    }\n\n    /**\n     * @notice Returns the profile struct and latest publication struct associated with the passed\n     * profile ID.\n     *\n     * @param handle The handle to query.\n     *\n     * @return LensData A struct containing the `ProfileStruct` and the `PublicationStruct` queried.\n     */\n    function getLatestDataByHandle(string memory handle) external view returns (LatestData memory) {\n        uint256 profileId = HUB.getProfileIdByHandle(handle);\n        DataTypes.ProfileStruct memory profileStruct = HUB.getProfile(profileId);\n        uint256 pubCount = profileStruct.pubCount;\n        return LatestData(profileStruct, HUB.getPub(profileId, pubCount));\n    }\n}\n"
    },
    "contracts/mocks/Currency.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract Currency is ERC20('Currency', 'CRNC') {\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/mocks/Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\n\n/**\n * @dev This is a helper contract used for internal testing.\n *\n * NOTE: This contract is not meant to be deployed and is unsafe for use.\n */\ncontract Helper {\n    /**\n     * @dev This is a helper function that exposes the block number due to the inconsistency of\n     * fetching the block number from scripts.\n     */\n    function getBlockNumber() external view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @dev This is a helper function to aid in testing same-block delegation in the FollowNFT contract.\n     */\n    function batchDelegate(\n        IFollowNFT nft,\n        address first,\n        address second\n    ) external {\n        nft.delegate(first);\n        nft.delegate(second);\n    }\n}\n"
    },
    "contracts/mocks/MockFollowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\n\ncontract MockFollowModule is IFollowModule {\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        pure\n        override\n        returns (bytes memory)\n    {\n        uint256 number = abi.decode(data, (uint256));\n        require(number == 1, 'MockFollowModule: invalid');\n        return new bytes(0);\n    }\n\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override {}\n\n    function isFollowing(\n        uint256 profileId,\n        address follower,\n        uint256 followNFTTokenId\n    ) external view override returns (bool) {\n        return true;\n    }\n\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n}\n"
    },
    "contracts/mocks/MockLensHubV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from '../core/base/LensNFTBase.sol';\nimport {LensMultiState} from '../core/base/LensMultiState.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\nimport {MockLensHubV2Storage} from './MockLensHubV2Storage.sol';\n\n/**\n * @dev A mock upgraded LensHub contract that is used mainly to validate that the initializer works as expected and\n * that the storage layout after an upgrade is valid.\n */\ncontract MockLensHubV2 is\n    LensNFTBase,\n    VersionedInitializable,\n    LensMultiState,\n    MockLensHubV2Storage\n{\n    uint256 internal constant REVISION = 2;\n\n    function initialize(uint256 newValue) external initializer {\n        _additionalValue = newValue;\n    }\n\n    function setAdditionalValue(uint256 newValue) external {\n        _additionalValue = newValue;\n    }\n\n    function getAdditionalValue() external view returns (uint256) {\n        return _additionalValue;\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n"
    },
    "contracts/mocks/MockLensHubV2BadRevision.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from '../core/base/LensNFTBase.sol';\nimport {LensMultiState} from '../core/base/LensMultiState.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\nimport {MockLensHubV2Storage} from './MockLensHubV2Storage.sol';\n\n/**\n * @dev A mock upgraded LensHub contract that is used to validate that the initializer cannot be called with the same revision.\n */\ncontract MockLensHubV2BadRevision is\n    LensNFTBase,\n    VersionedInitializable,\n    LensMultiState,\n    MockLensHubV2Storage\n{\n    uint256 internal constant REVISION = 1; // Should fail the initializer check\n\n    function initialize(uint256 newValue) external initializer {\n        _additionalValue = newValue;\n    }\n\n    function setAdditionalValue(uint256 newValue) external {\n        _additionalValue = newValue;\n    }\n\n    function getAdditionalValue() external view returns (uint256) {\n        return _additionalValue;\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n"
    },
    "contracts/mocks/MockLensHubV2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../libraries/DataTypes.sol';\n\ncontract MockLensHubV2Storage {\n    bytes32 internal constant CREATE_PROFILE_WITH_SIG_TYPEHASH =\n        0x9ac3269d9abd6f8c5e850e07f21b199079e8a5cc4a55466d8c96ab0c4a5be403;\n    // keccak256(\n    // 'CreateProfileWithSig(string handle,string uri,address followModule,bytes followModuleData,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH =\n        0x6f3f6455a608af1cc57ef3e5c0a49deeb88bba264ec8865b798ff07358859d4b;\n    // keccak256(\n    // 'SetFollowModuleWithSig(uint256 profileId,address followModule,bytes followModuleData,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant SET_DISPATCHER_WITH_SIG_TYPEHASH =\n        0x77ba3e9f5fa75343bbad1241fb539a0064de97694b47d463d1eb5c54aba11f0f;\n    // keccak256(\n    // 'SetDispatcherWithSig(uint256 profileId,address dispatcher,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH =\n        0x5b9860bd835e648945b22d053515bc1f53b7d9fab4b23b1b49db15722e945d14;\n    // keccak256(\n    // 'SetProfileImageURIWithSig(uint256 profileId,string imageURI,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant POST_WITH_SIG_TYPEHASH =\n        0xfb8f057542e7551386ead0b891a45f102af78c47f8cc58b4a919c7cfeccd0e1e;\n    // keccak256(\n    // 'PostWithSig(uint256 profileId,string contentURI,address collectModule,bytes collectModuleData,address referenceModule,bytes referenceModuleData,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant COMMENT_WITH_SIG_TYPEHASH =\n        0xb30910150df56294e05b2d03e181803697a2b935abb1b9bdddde9310f618fe9b;\n    // keccak256(\n    // 'CommentWithSig(uint256 profileId,string contentURI,uint256 profileIdPointed,uint256 pubIdPointed,address collectModule,bytes collectModuleData,address referenceModule,bytes referenceModuleData,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant MIRROR_WITH_SIG_TYPEHASH =\n        0x64f4578fc098f96a2450fbe601cb8c5318ebeb2ff72d2031a36be1ff6932d5ee;\n    // keccak256(\n    // 'MirrorWithSig(uint256 profileId,uint256 profileIdPointed,uint256 pubIdPointed,address referenceModule,bytes referenceModuleData,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant FOLLOW_WITH_SIG_TYPEHASH =\n        0xfb6b7f1cd1b38daf3822aff0abbe78124db5d62a4748bcff007c15ccd6d30bc5;\n    // keccak256(\n    // 'FollowWithSig(uint256[] profileIds,bytes[] datas,uint256 nonce,uint256 deadline)'\n    // );\n    bytes32 internal constant COLLECT_WITH_SIG_TYPEHASH =\n        0x7f9b4ea1fc678b4fda1611ac5cbd28f339e235d89b1540635e9b2e0223a3c101;\n    // keccak256(\n    // 'CollectWithSig(uint256 profileId,uint256 pubId,bytes data,uint256 nonce,uint256 deadline)'\n    // );\n\n    mapping(address => bool) internal _followModuleWhitelisted;\n    mapping(address => bool) internal _collectModuleWhitelisted;\n    mapping(address => bool) internal _referenceModuleWhitelisted;\n\n    mapping(uint256 => address) internal _dispatcherByProfile;\n    mapping(bytes32 => uint256) internal _profileIdByHandleHash;\n    mapping(uint256 => DataTypes.ProfileStruct) internal _profileById;\n    mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct)) internal _pubByIdByProfile;\n\n    mapping(address => uint256) internal _defaultProfileByAddress;\n\n    uint256 internal _profileCounter;\n    address internal _governance;\n    address internal _emergencyAdmin;\n    uint256 internal _additionalValue;\n}\n"
    },
    "contracts/mocks/MockProfileCreationProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\n\n/**\n * @title MockProfileCreationProxy\n * @author Lens Protocol\n *\n * @notice This is a proxy contract that enforces \".test\" handle suffixes and adds char validations at profile creation.\n */\ncontract MockProfileCreationProxy {\n    ILensHub immutable LENS_HUB;\n\n    constructor(ILensHub hub) {\n        LENS_HUB = hub;\n    }\n\n    function proxyCreateProfile(DataTypes.CreateProfileData memory vars) external {\n        uint256 handleLength = bytes(vars.handle).length;\n        if (handleLength < 5) revert Errors.HandleLengthInvalid();\n\n        bytes1 firstByte = bytes(vars.handle)[0];\n        if (firstByte == '-' || firstByte == '_' || firstByte == '.')\n            revert Errors.HandleFirstCharInvalid();\n\n        for (uint256 i = 1; i < handleLength; ) {\n            if (bytes(vars.handle)[i] == '.') revert Errors.HandleContainsInvalidCharacters();\n            unchecked {\n                ++i;\n            }\n        }\n\n        vars.handle = string(abi.encodePacked(vars.handle, '.test'));\n        LENS_HUB.createProfile(vars);\n    }\n}\n"
    },
    "contracts/mocks/MockReferenceModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n\ncontract MockReferenceModule is IReferenceModule {\n    function initializeReferenceModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external pure override returns (bytes memory) {\n        uint256 number = abi.decode(data, (uint256));\n        require(number == 1, 'MockReferenceModule: invalid');\n        return new bytes(0);\n    }\n\n    function processComment(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes calldata data\n    ) external override {}\n\n    function processMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        bytes calldata data\n    ) external override {}\n}\n"
    },
    "contracts/upgradeability/FollowNFTProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Proxy} from '@openzeppelin/contracts/proxy/Proxy.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\ncontract FollowNFTProxy is Proxy {\n    using Address for address;\n    address immutable HUB;\n\n    constructor(bytes memory data) {\n        HUB = msg.sender;\n        ILensHub(msg.sender).getFollowNFTImpl().functionDelegateCall(data);\n    }\n\n    function _implementation() internal view override returns (address) {\n        return ILensHub(HUB).getFollowNFTImpl();\n    }\n}\n"
    },
    "contracts/upgradeability/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * NOTE: This is a direct copy of OpenZeppelin's TransparentUpgradeableProxy and is only present for\n * ease of explorer verification.\n *\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {Errors} from '../libraries/Errors.sol';\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * This is slightly modified from [Aave's version.](https://github.com/aave/protocol-v2/blob/6a503eb0a897124d8b9d126c915ffdf3e88343a9/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol)\n *\n * @author Lens Protocol, inspired by Aave's implementation, which is in turn inspired by OpenZeppelin's\n * Initializable contract\n */\nabstract contract VersionedInitializable {\n    address private immutable originalImpl;\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 private lastInitializedRevision = 0;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        if (address(this) == originalImpl) revert Errors.CannotInitImplementation();\n        if (revision <= lastInitializedRevision) revert Errors.Initialized();\n        lastInitializedRevision = revision;\n        _;\n    }\n\n    constructor() {\n        originalImpl = address(this);\n    }\n\n    /**\n     * @dev returns the revision number of the contract\n     * Needs to be defined in the inherited class as a constant.\n     **/\n    function getRevision() internal pure virtual returns (uint256);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}